// MiniML VM - browser bundle (generated by browser.js)
(function(global) {
"use strict";

// ---- vm.js ----
// VM core — direct port of lib/vm.ml

class RuntimeError extends Error {
  constructor(msg) { super(msg); this.name = "RuntimeError"; }
}

function error(msg) { throw new RuntimeError(msg); }

// --- Value constructors ---
const VUNIT = { tag: "unit" };
const vint = (v) => ({ tag: "int", v });
const vfloat = (v) => ({ tag: "float", v });
const vbool = (v) => v ? VTRUE : VFALSE;
const VTRUE = { tag: "bool", v: true };
const VFALSE = { tag: "bool", v: false };
const vstring = (v) => ({ tag: "string", v });
const vbyte = (v) => ({ tag: "byte", v: v & 0xFF });
const vrune = (v) => ({ tag: "rune", v });
const vtuple = (vs) => ({ tag: "tuple", v: vs });
const vlist = (vs) => ({ tag: "list", v: vs });
const VNIL = vlist([]);
const vrecord = (fields) => ({ tag: "record", v: fields }); // fields: [[name, val], ...]
const vvariant = (tagN, name, payload) => ({ tag: "variant", tagN, name, payload });
const vclosure = (proto, upvalues) => ({ tag: "closure", proto, upvalues });
const vexternal = (name, arity, fn, args) => ({ tag: "external", name, arity, fn, args: args || [] });
const vcontinuation = (fiber, returnHandler, opHandlers) =>
  ({ tag: "continuation", fiber, returnHandler, opHandlers, used: false });
const vref = (v) => ({ tag: "ref", v: [v] }); // use array for mutability
const vmap = (pairs) => ({ tag: "map", v: pairs }); // pairs: [[k, v], ...]
const varray = (elems) => ({ tag: "array", v: elems });
const vproto = (p) => ({ tag: "proto", v: p });

// --- Value accessors ---
function asInt(v) { if (v.tag === "int") return v.v; error(`expected int, got ${ppValue(v)}`); }
function asFloat(v) { if (v.tag === "float") return v.v; error(`expected float, got ${ppValue(v)}`); }
function asBool(v) { if (v.tag === "bool") return v.v; error(`expected bool, got ${ppValue(v)}`); }
function asString(v) { if (v.tag === "string") return v.v; error(`expected string, got ${ppValue(v)}`); }
function asClosure(v) { if (v.tag === "closure") return v; error(`expected function, got ${ppValue(v)}`); }
function asTuple(v) { if (v.tag === "tuple") return v.v; error(`expected tuple, got ${ppValue(v)}`); }
function asRecord(v) { if (v.tag === "record") return v.v; error(`expected record, got ${ppValue(v)}`); }
function asList(v) { if (v.tag === "list") return v.v; error(`expected list, got ${ppValue(v)}`); }
function asVariant(v) { if (v.tag === "variant") return v; error(`expected variant, got ${ppValue(v)}`); }
function asContinuation(v) { if (v.tag === "continuation") return v; error(`expected continuation, got ${ppValue(v)}`); }
function asByte(v) { if (v.tag === "byte") return v.v; error(`expected byte, got ${ppValue(v)}`); }
function asRune(v) { if (v.tag === "rune") return v.v; error(`expected rune, got ${ppValue(v)}`); }
function asMap(v) { if (v.tag === "map") return v.v; error(`expected map, got ${ppValue(v)}`); }
function asArray(v) { if (v.tag === "array") return v.v; error(`expected array, got ${ppValue(v)}`); }

// --- Structural equality (matches vm.ml values_equal) ---
function valuesEqual(a, b) {
  if (a === b) return true;
  if (a.tag !== b.tag) return false;
  switch (a.tag) {
    case "int": case "float": case "bool": case "byte": case "rune":
      return a.v === b.v;
    case "string":
      return a.v === b.v;
    case "unit":
      return true;
    case "tuple":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) if (!valuesEqual(a.v[i], b.v[i])) return false;
      return true;
    case "list":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) if (!valuesEqual(a.v[i], b.v[i])) return false;
      return true;
    case "variant":
      if (a.tagN !== b.tagN) return false;
      if (a.payload === null && b.payload === null) return true;
      if (a.payload !== null && b.payload !== null) return valuesEqual(a.payload, b.payload);
      return false;
    case "record":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) {
        if (a.v[i][0] !== b.v[i][0] || !valuesEqual(a.v[i][1], b.v[i][1])) return false;
      }
      return true;
    case "array":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) if (!valuesEqual(a.v[i], b.v[i])) return false;
      return true;
    default:
      return false;
  }
}

// --- Pretty-print (matches bytecode.ml pp_value) ---
function runeToUtf8(cp) {
  if (cp < 0x80) return String.fromCharCode(cp);
  if (cp < 0x800) return String.fromCharCode(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
  if (cp < 0x10000)
    return String.fromCharCode(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
  return String.fromCodePoint(cp);
}

function ppValue(v) {
  switch (v.tag) {
    case "int": return String(v.v);
    case "float": {
      let s = String(v.v);
      if (!s.includes('.') && !s.includes('e') && !s.includes('E') && isFinite(v.v)) s += ".";
      return s;
    }
    case "bool": return v.v ? "true" : "false";
    case "string": return v.v;
    case "byte": return "#" + v.v.toString(16).padStart(2, '0');
    case "rune": return "`" + runeToUtf8(v.v);
    case "unit": return "()";
    case "tuple": return "(" + v.v.map(ppValue).join(", ") + ")";
    case "list": return "[" + v.v.map(ppValue).join("; ") + "]";
    case "record":
      return "{ " + v.v.map(([n, val]) => n + " = " + ppValue(val)).join("; ") + " }";
    case "variant":
      if (v.payload === null) return v.name;
      const pv = ppValue(v.payload);
      if (v.payload.tag === "tuple" || (v.payload.tag === "variant" && v.payload.payload !== null))
        return v.name + " (" + pv + ")";
      return v.name + " " + pv;
    case "closure": return "<fun>";
    case "external":
      if (v.args.length === 0) return `<external:${v.name}>`;
      return "<fun>";
    case "proto": return `<proto:${v.v.name}>`;
    case "continuation": return "<continuation>";
    case "ref": return `ref(${ppValue(v.v[0])})`;
    case "map": {
      const isSet = v.v.every(([_, val]) => val.tag === "unit");
      if (isSet) return "#{" + v.v.map(([k]) => ppValue(k)).join("; ") + "}";
      return "#{" + v.v.map(([k, val]) => ppValue(k) + ": " + ppValue(val)).join("; ") + "}";
    }
    case "array": return "#[" + v.v.map(ppValue).join("; ") + "]";
    default: return "<unknown>";
  }
}

// --- Fiber ---
const STACK_SIZE = 65536;

function makeFiber() {
  return { stack: new Array(STACK_SIZE), sp: 0, frames: [] };
}

function copyFiber(f) {
  const newStack = f.stack.slice();
  const newFrames = f.frames.map(fr => ({
    closure: fr.closure,
    ip: fr.ip,
    locals: fr.locals.slice(),
    baseSp: fr.baseSp,
  }));
  return { stack: newStack, sp: f.sp, frames: newFrames };
}

// --- VM dispatch loop ---
function run(vm) {
  let fiber = vm.currentFiber;

  function push(v) {
    if (fiber.sp >= STACK_SIZE) error("stack overflow");
    fiber.stack[fiber.sp++] = v;
  }
  function pop() {
    if (fiber.sp <= 0) error("stack underflow");
    return fiber.stack[--fiber.sp];
  }
  function peek() {
    if (fiber.sp <= 0) error("stack underflow");
    return fiber.stack[fiber.sp - 1];
  }
  function frame() { return fiber.frames[fiber.frames.length - 1]; }
  function proto() { return frame().closure.proto; }

  function findHandler(opName) {
    for (const he of vm.handlerStack) {
      for (const [name] of he.ops) {
        if (name === opName) return he;
      }
    }
    return null;
  }

  function findHandlerForFiber(f) {
    for (const he of vm.handlerStack) {
      if (he.bodyFiber === f) return he;
    }
    return null;
  }

  function removeHandler(he) {
    vm.handlerStack = vm.handlerStack.filter(h => h !== he);
  }

  function internalCall(cls, arg) {
    const newLocals = new Array(cls.proto.num_locals).fill(VUNIT);
    newLocals[0] = arg;
    fiber.frames.push({ closure: cls, ip: 0, locals: newLocals, baseSp: fiber.sp });
  }

  try {
    while (true) {
      const f = frame();
      const op = f.closure.proto.code[f.ip++];
      const opName = op[0];

      switch (opName) {
        case "CONST":
          push(proto().constants[op[1]]);
          break;
        case "POP":
          pop();
          break;
        case "DUP":
          push(peek());
          break;
        case "GET_LOCAL":
          push(f.locals[op[1]]);
          break;
        case "SET_LOCAL":
          f.locals[op[1]] = pop();
          break;
        case "GET_UPVALUE":
          push(f.closure.upvalues[op[1]]);
          break;
        case "SET_UPVALUE":
          f.closure.upvalues[op[1]] = pop();
          break;
        case "MAKE_REF": {
          const v = pop();
          push(vref(v));
          break;
        }
        case "DEREF": {
          const r = pop();
          if (r.tag !== "ref") error("DEREF on non-ref value");
          push(r.v[0]);
          break;
        }
        case "SET_REF": {
          const r = pop();
          const v = pop();
          if (r.tag !== "ref") error("SET_REF on non-ref value");
          r.v[0] = v;
          break;
        }
        case "GET_GLOBAL": {
          const idx = op[1];
          const v = vm.globals.get(idx);
          if (v === undefined) {
            const name = idx < vm.globalNames.length ? vm.globalNames[idx] : "?";
            error(`undefined global: ${name}`);
          }
          push(v);
          break;
        }
        case "SET_GLOBAL":
          vm.globals.set(op[1], pop());
          break;
        case "DEF_GLOBAL":
          vm.globals.set(op[1], pop());
          break;
        case "ADD": {
          const b = pop(), a = pop();
          push(vint(asInt(a) + asInt(b)));
          break;
        }
        case "SUB": {
          const b = pop(), a = pop();
          push(vint(asInt(a) - asInt(b)));
          break;
        }
        case "MUL": {
          const b = pop(), a = pop();
          push(vint(asInt(a) * asInt(b)));
          break;
        }
        case "DIV": {
          const b = pop(), a = pop();
          const bv = asInt(b);
          if (bv === 0) error("division by zero");
          push(vint(Math.trunc(asInt(a) / bv)));
          break;
        }
        case "MOD": {
          const b = pop(), a = pop();
          const bv = asInt(b);
          if (bv === 0) error("modulo by zero");
          push(vint(asInt(a) % bv));
          break;
        }
        case "NEG": {
          push(vint(-asInt(pop())));
          break;
        }
        case "FADD": {
          const b = pop(), a = pop();
          push(vfloat(asFloat(a) + asFloat(b)));
          break;
        }
        case "FSUB": {
          const b = pop(), a = pop();
          push(vfloat(asFloat(a) - asFloat(b)));
          break;
        }
        case "FMUL": {
          const b = pop(), a = pop();
          push(vfloat(asFloat(a) * asFloat(b)));
          break;
        }
        case "FDIV": {
          const b = pop(), a = pop();
          push(vfloat(asFloat(a) / asFloat(b)));
          break;
        }
        case "FNEG": {
          push(vfloat(-asFloat(pop())));
          break;
        }
        case "EQ": {
          const b = pop(), a = pop();
          push(vbool(valuesEqual(a, b)));
          break;
        }
        case "NEQ": {
          const b = pop(), a = pop();
          push(vbool(!valuesEqual(a, b)));
          break;
        }
        case "LT": {
          const b = pop(), a = pop();
          let result;
          if (a.tag === "float" && b.tag === "float") result = a.v < b.v;
          else if (a.tag === "string" && b.tag === "string") result = a.v < b.v;
          else if (a.tag === "byte" && b.tag === "byte") result = a.v < b.v;
          else if (a.tag === "rune" && b.tag === "rune") result = a.v < b.v;
          else result = asInt(a) < asInt(b);
          push(vbool(result));
          break;
        }
        case "GT": {
          const b = pop(), a = pop();
          let result;
          if (a.tag === "float" && b.tag === "float") result = a.v > b.v;
          else if (a.tag === "string" && b.tag === "string") result = a.v > b.v;
          else if (a.tag === "byte" && b.tag === "byte") result = a.v > b.v;
          else if (a.tag === "rune" && b.tag === "rune") result = a.v > b.v;
          else result = asInt(a) > asInt(b);
          push(vbool(result));
          break;
        }
        case "LE": {
          const b = pop(), a = pop();
          let result;
          if (a.tag === "float" && b.tag === "float") result = a.v <= b.v;
          else if (a.tag === "string" && b.tag === "string") result = a.v <= b.v;
          else if (a.tag === "byte" && b.tag === "byte") result = a.v <= b.v;
          else if (a.tag === "rune" && b.tag === "rune") result = a.v <= b.v;
          else result = asInt(a) <= asInt(b);
          push(vbool(result));
          break;
        }
        case "GE": {
          const b = pop(), a = pop();
          let result;
          if (a.tag === "float" && b.tag === "float") result = a.v >= b.v;
          else if (a.tag === "string" && b.tag === "string") result = a.v >= b.v;
          else if (a.tag === "byte" && b.tag === "byte") result = a.v >= b.v;
          else if (a.tag === "rune" && b.tag === "rune") result = a.v >= b.v;
          else result = asInt(a) >= asInt(b);
          push(vbool(result));
          break;
        }
        case "NOT":
          push(vbool(!asBool(pop())));
          break;
        case "BAND": {
          const b = pop(), a = pop();
          push(vint(asInt(a) & asInt(b)));
          break;
        }
        case "BOR": {
          const b = pop(), a = pop();
          push(vint(asInt(a) | asInt(b)));
          break;
        }
        case "BXOR": {
          const b = pop(), a = pop();
          push(vint(asInt(a) ^ asInt(b)));
          break;
        }
        case "BNOT":
          push(vint(~asInt(pop())));
          break;
        case "BSHL": {
          const b = pop(), a = pop();
          push(vint(asInt(a) << asInt(b)));
          break;
        }
        case "BSHR": {
          const b = pop(), a = pop();
          push(vint(asInt(a) >>> asInt(b)));
          break;
        }
        case "JUMP":
          frame().ip = op[1];
          break;
        case "JUMP_IF_FALSE": {
          const v = pop();
          if (!asBool(v)) frame().ip = op[1];
          break;
        }
        case "JUMP_IF_TRUE": {
          const v = pop();
          if (asBool(v)) frame().ip = op[1];
          break;
        }
        case "CLOSURE": {
          const protoIdx = op[1];
          const captures = op[2];
          const fnProto = getProto(proto(), protoIdx);
          const upvalues = captures.map(cap => resolveCapture(f, cap));
          push(vclosure(fnProto, upvalues));
          break;
        }
        case "CLOSURE_REC": {
          const protoIdx = op[1];
          const captures = op[2];
          const selfIdx = op[3];
          const fnProto = getProto(proto(), protoIdx);
          const upvalues = captures.map(cap => resolveCapture(f, cap));
          const cls = vclosure(fnProto, upvalues);
          cls.upvalues[selfIdx] = cls; // circular reference for recursion
          push(cls);
          break;
        }
        case "CALL": {
          const arg = pop();
          const fnVal = pop();
          if (fnVal.tag === "closure") {
            const baseSp = fiber.sp;
            const newLocals = new Array(fnVal.proto.num_locals).fill(VUNIT);
            newLocals[0] = arg;
            fiber.frames.push({ closure: fnVal, ip: 0, locals: newLocals, baseSp });
          } else if (fnVal.tag === "external") {
            const newArgs = fnVal.args.concat([arg]);
            if (newArgs.length === fnVal.arity) {
              push(fnVal.fn(newArgs));
            } else {
              push(vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs));
            }
          } else {
            error(`expected function, got ${ppValue(fnVal)}`);
          }
          break;
        }
        case "TAIL_CALL": {
          const arg = pop();
          const fnVal = pop();
          if (fnVal.tag === "closure") {
            const currentBaseSp = frame().baseSp;
            const newLocals = new Array(fnVal.proto.num_locals).fill(VUNIT);
            newLocals[0] = arg;
            fiber.frames[fiber.frames.length - 1] = { closure: fnVal, ip: 0, locals: newLocals, baseSp: currentBaseSp };
          } else if (fnVal.tag === "external") {
            const newArgs = fnVal.args.concat([arg]);
            if (newArgs.length === fnVal.arity) {
              push(fnVal.fn(newArgs));
            } else {
              push(vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs));
            }
          } else {
            error(`expected function, got ${ppValue(fnVal)}`);
          }
          break;
        }
        case "RETURN": {
          const result = pop();
          fiber.frames.pop();
          if (fiber.frames.length === 0) {
            // Last frame — check for handler
            const he = findHandlerForFiber(fiber);
            if (he) {
              removeHandler(he);
              fiber = he.parentFiber;
              vm.currentFiber = fiber;
              internalCall(asClosure(he.returnHandler), result);
            } else {
              return result;
            }
          } else {
            push(result);
          }
          break;
        }
        case "MAKE_TUPLE": {
          const n = op[1];
          const values = new Array(n);
          for (let i = n - 1; i >= 0; i--) values[i] = pop();
          push(vtuple(values));
          break;
        }
        case "TUPLE_GET": {
          const idx = op[1];
          const tup = asTuple(pop());
          if (idx >= tup.length) error("tuple index out of bounds");
          push(tup[idx]);
          break;
        }
        case "MAKE_RECORD": {
          const fieldNames = op[1];
          const n = fieldNames.length;
          const values = new Array(n);
          for (let i = n - 1; i >= 0; i--) values[i] = pop();
          const fields = fieldNames.map((name, i) => [name, values[i]]);
          push(vrecord(fields));
          break;
        }
        case "FIELD": {
          const name = op[1];
          const rec = asRecord(pop());
          const entry = rec.find(([n]) => n === name);
          if (!entry) error(`record has no field: ${name}`);
          push(entry[1]);
          break;
        }
        case "SET_FIELD": {
          const name = op[1];
          const newVal = pop();
          const rec = asRecord(pop());
          let found = false;
          for (let i = 0; i < rec.length; i++) {
            if (rec[i][0] === name) { rec[i] = [name, newVal]; found = true; break; }
          }
          if (!found) error(`record has no field: ${name}`);
          break;
        }
        case "MAKE_VARIANT": {
          const [, tagN, name, hasPayload] = op;
          if (hasPayload) {
            push(vvariant(tagN, name, pop()));
          } else {
            push(vvariant(tagN, name, null));
          }
          break;
        }
        case "CONS": {
          const tl = pop();
          const hd = pop();
          const tlList = asList(tl);
          push(vlist([hd, ...tlList]));
          break;
        }
        case "NIL":
          push(VNIL);
          break;
        case "TAG_EQ": {
          const tagN = op[1];
          const v = asVariant(pop());
          push(vbool(v.tagN === tagN));
          break;
        }
        case "IS_NIL": {
          const l = asList(pop());
          push(vbool(l.length === 0));
          break;
        }
        case "IS_CONS": {
          const l = asList(pop());
          push(vbool(l.length > 0));
          break;
        }
        case "HEAD": {
          const l = asList(pop());
          if (l.length === 0) error("head of empty list");
          push(l[0]);
          break;
        }
        case "TAIL": {
          const l = asList(pop());
          if (l.length === 0) error("tail of empty list");
          push(vlist(l.slice(1)));
          break;
        }
        case "VARIANT_PAYLOAD": {
          const v = asVariant(pop());
          if (v.payload === null) error("variant has no payload");
          push(v.payload);
          break;
        }
        case "MATCH_FAIL":
          error("non-exhaustive match");
          break;
        case "PERFORM": {
          const opNameStr = op[1];
          const arg = pop();
          const he = findHandler(opNameStr);
          if (!he) error(`unhandled effect operation: ${opNameStr}`);
          const handlerFn = he.ops.find(([name]) => name === opNameStr)[1];
          const cont = vcontinuation(fiber, he.returnHandler, he.ops);
          const pair = vtuple([arg, cont]);
          removeHandler(he);
          fiber = he.parentFiber;
          vm.currentFiber = fiber;
          internalCall(asClosure(handlerFn), pair);
          break;
        }
        case "HANDLE": {
          const nOps = op[1];
          const ops = [];
          for (let i = 0; i < nOps; i++) {
            const handlerClosure = pop();
            const opStr = asString(pop());
            ops.push([opStr, handlerClosure]);
          }
          const returnHandler = pop();
          const bodyThunk = pop();
          const bodyFiber = makeFiber();
          const he = {
            returnHandler,
            ops,
            bodyFiber,
            parentFiber: fiber,
          };
          vm.handlerStack.push(he);
          fiber = bodyFiber;
          vm.currentFiber = fiber;
          internalCall(asClosure(bodyThunk), VUNIT);
          break;
        }
        case "RESUME": {
          const v = pop();
          const cont = asContinuation(pop());
          if (cont.used) error("continuation already resumed");
          cont.used = true;
          const bodyFiber = cont.fiber;
          bodyFiber.stack[bodyFiber.sp++] = v;
          const he = {
            returnHandler: cont.returnHandler,
            ops: cont.opHandlers,
            bodyFiber,
            parentFiber: fiber,
          };
          vm.handlerStack.push(he);
          fiber = bodyFiber;
          vm.currentFiber = fiber;
          break;
        }
        case "ENTER_LOOP": {
          const breakTarget = op[1];
          vm.controlStack.push({
            breakIp: breakTarget,
            fiber: fiber,
            frameDepth: fiber.frames.length,
            stackDepth: fiber.sp,
          });
          break;
        }
        case "EXIT_LOOP": {
          if (vm.controlStack.length === 0) error("EXIT_LOOP: no control entry");
          vm.controlStack.pop();
          break;
        }
        case "LOOP_BREAK": {
          const breakValue = pop();
          if (vm.controlStack.length === 0) error("LOOP_BREAK: no control entry");
          const ce = vm.controlStack.pop();
          const f = ce.fiber;
          while (f.frames.length > ce.frameDepth) f.frames.pop();
          f.sp = ce.stackDepth;
          vm.currentFiber = f;
          fiber = f;
          push(breakValue);
          frame().ip = ce.breakIp;
          break;
        }
        case "LOOP_CONTINUE": {
          const target = op[1];
          if (vm.controlStack.length === 0) error("LOOP_CONTINUE: no control entry");
          const ce = vm.controlStack[vm.controlStack.length - 1];
          ce.fiber.sp = ce.stackDepth;
          frame().ip = target;
          break;
        }
        case "FOLD_CONTINUE": {
          const nPops = op[1];
          const continueValue = pop();
          for (let i = 0; i < nPops; i++) {
            if (fiber.sp > 0) fiber.sp--;
          }
          push(continueValue);
          // Execute RETURN from fold callback
          const result = pop();
          if (fiber.frames.length <= 1) error("FOLD_CONTINUE: no frame to return from");
          fiber.frames.pop();
          push(result);
          break;
        }
        case "ENTER_FUNC": {
          vm.returnStack.push({
            fiber: fiber,
            frameDepth: fiber.frames.length,
          });
          break;
        }
        case "EXIT_FUNC": {
          if (vm.returnStack.length === 0) error("EXIT_FUNC: no return entry");
          vm.returnStack.pop();
          break;
        }
        case "FUNC_RETURN": {
          const result = pop();
          // Find and remove the return entry for this fiber
          let reIdx = -1;
          for (let i = vm.returnStack.length - 1; i >= 0; i--) {
            if (vm.returnStack[i].fiber === fiber) { reIdx = i; break; }
          }
          if (reIdx === -1) error("FUNC_RETURN: no return entry");
          const re = vm.returnStack[reIdx];
          vm.returnStack.splice(reIdx, 1);
          const targetDepth = re.frameDepth;
          // Unwind frames back to the target function
          while (fiber.frames.length > targetDepth) fiber.frames.pop();
          // Clean up control_stack entries above target depth
          vm.controlStack = vm.controlStack.filter(ce =>
            !(ce.fiber === fiber && ce.frameDepth >= targetDepth)
          );
          // Restore stack pointer and pop the target function's frame
          const baseSp = frame().baseSp;
          fiber.sp = baseSp;
          fiber.frames.pop();
          if (fiber.frames.length === 0) {
            const he = findHandlerForFiber(fiber);
            if (he) {
              removeHandler(he);
              fiber = he.parentFiber;
              vm.currentFiber = fiber;
              internalCall(asClosure(he.returnHandler), result);
            } else {
              return result;
            }
          } else {
            push(result);
          }
          break;
        }
        case "MAKE_MAP": {
          const n = op[1];
          const pairs = [];
          for (let i = 0; i < n; i++) {
            const v = pop();
            const k = pop();
            pairs.unshift([k, v]);
          }
          push(vmap(pairs));
          break;
        }
        case "MAKE_ARRAY": {
          const n = op[1];
          const elems = [];
          for (let i = 0; i < n; i++) {
            elems.unshift(pop());
          }
          push(varray(elems));
          break;
        }
        case "INDEX": {
          const idx = asInt(pop());
          const base = pop();
          if (base.tag === "string") {
            const s = base.v;
            // Get byte at index (matching OCaml's string byte indexing)
            const encoder = new TextEncoder();
            const bytes = encoder.encode(s);
            if (idx < 0 || idx >= bytes.length)
              error(`string index out of bounds: ${idx} (length ${bytes.length})`);
            push(vbyte(bytes[idx]));
          } else if (base.tag === "array") {
            if (idx < 0 || idx >= base.v.length)
              error(`array index out of bounds: ${idx} (length ${base.v.length})`);
            push(base.v[idx]);
          } else {
            error("index operation requires string or array");
          }
          break;
        }
        case "HALT":
          return fiber.sp > 0 ? peek() : VUNIT;
        default:
          error(`unknown opcode: ${opName}`);
      }
    }
  } catch (e) {
    if (e instanceof RuntimeError) {
      const f = fiber.frames.length > 0 ? fiber.frames[fiber.frames.length - 1] : null;
      if (f) {
        const ip = Math.max(0, f.ip - 1);
        const lt = f.closure.proto.line_table;
        const line = lt && ip < lt.length ? lt[ip] : 0;
        if (line > 0) throw new RuntimeError(`[line ${line}] ${e.message}`);
      }
    }
    throw e;
  }
}

function getProto(currentProto, protoIdx) {
  const c = currentProto.constants[protoIdx];
  if (c.tag !== "proto") error(`expected prototype at constant ${protoIdx}`);
  return c.v;
}

function resolveCapture(frame, cap) {
  if (cap[0] === "local") return frame.locals[cap[1]];
  if (cap[0] === "upvalue") return frame.closure.upvalues[cap[1]];
  error(`unknown capture type: ${cap[0]}`);
}

// --- Execute a prototype in a VM ---
function executeProto(vm, proto) {
  const fiber = makeFiber();
  const closure = vclosure(proto, []);
  const locals = new Array(proto.num_locals).fill(VUNIT);
  fiber.frames.push({ closure, ip: 0, locals, baseSp: 0 });
  vm.currentFiber = fiber;
  return run(vm);
}

// --- Create a fresh VM ---
function createVM(globalNames) {
  return {
    currentFiber: makeFiber(),
    handlerStack: [],
    controlStack: [],
    returnStack: [],
    globals: new Map(),
    globalNames,
  };
}



// ---- builtins.js ----
// JS implementations of native builtins — matches interp.ml + std.ml externals


function stringToUtf8Bytes(s) {
  return new TextEncoder().encode(s);
}

function utf8BytesToString(bytes) {
  return new TextDecoder().decode(bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes));
}

// Build builtins map: ext_name -> { arity, fn }
const builtins = {};

function reg(name, arity, fn) {
  builtins[name] = { arity, fn };
}

// --- Core builtins (interp.ml) ---

reg("mod", 2, (args) => {
  const b = asInt(args[1]);
  if (b === 0) error("modulo by zero");
  return vint(asInt(args[0]) % b);
});

reg("print", 1, (args) => {
  const output = ppValue(args[0]);
  if (typeof globalThis._vmOutput === "function") {
    globalThis._vmOutput(output);
  } else {
    console.log(output);
  }
  return VUNIT;
});

reg("failwith", 1, (args) => {
  error(asString(args[0]));
});

reg("^", 2, (args) =>
  vstring(asString(args[0]) + asString(args[1])));

reg("&&", 2, (args) =>
  vbool(asBool(args[0]) && asBool(args[1])));

reg("||", 2, (args) =>
  vbool(asBool(args[0]) || asBool(args[1])));

reg("not", 1, (args) =>
  vbool(!asBool(args[0])));

reg("phys_equal", 2, (args) =>
  vbool(args[0] === args[1]));

reg("float_of_int", 1, (args) =>
  vfloat(asInt(args[0])));

reg("int_of_float", 1, (args) =>
  vint(Math.trunc(asFloat(args[0]))));

reg("string_of_int", 1, (args) =>
  vstring(String(asInt(args[0]))));

reg("string_of_float", 1, (args) => {
  let f = asFloat(args[0]);
  // Match OCaml's %g format
  let s = formatFloat(f);
  return vstring(s);
});

reg("string_of_bool", 1, (args) =>
  vstring(asBool(args[0]) ? "true" : "false"));

// Map pattern matching helpers
reg("__map_has", 2, (args) => {
  const pairs = asMap(args[0]);
  const key = args[1];
  return vbool(pairs.some(([k]) => valuesEqual(k, key)));
});

reg("__map_get", 2, (args) => {
  const pairs = asMap(args[0]);
  const key = args[1];
  const entry = pairs.find(([k]) => valuesEqual(k, key));
  if (!entry) error("key not found in map");
  return entry[1];
});

// Array operations
reg("array_get", 2, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  return arr[idx];
});

reg("array_length", 1, (args) =>
  vint(asArray(args[0]).length));

// Byte primitives
reg("__byte_to_int", 1, (args) =>
  vint(asByte(args[0])));

reg("__byte_of_int", 1, (args) =>
  vbyte(asInt(args[0]) & 0xFF));

reg("__byte_to_string", 1, (args) => {
  const b = asByte(args[0]);
  return vstring(String.fromCharCode(b));
});

// Rune primitives
reg("__rune_to_int", 1, (args) =>
  vint(asRune(args[0])));

reg("__rune_of_int", 1, (args) =>
  vrune(asInt(args[0])));

reg("__rune_to_string", 1, (args) => {
  const cp = asRune(args[0]);
  return vstring(runeToUtf8(cp));
});

// Math primitives
reg("__math_pow", 2, (args) =>
  vfloat(Math.pow(asFloat(args[0]), asFloat(args[1]))));

reg("__math_sqrt", 1, (args) =>
  vfloat(Math.sqrt(asFloat(args[0]))));

reg("__math_floor", 1, (args) =>
  vint(Math.floor(asFloat(args[0]))));

reg("__math_ceil", 1, (args) =>
  vint(Math.ceil(asFloat(args[0]))));

reg("__math_round", 1, (args) =>
  vint(Math.round(asFloat(args[0]))));

// --- Format specifier builtins (interp.ml __fmt_*) ---

reg("__fmt_float", 2, (args) => {
  const prec = asInt(args[0]);
  const f = asFloat(args[1]);
  return vstring(f.toFixed(prec));
});

reg("__fmt_hex", 1, (args) =>
  vstring(asInt(args[0]).toString(16)));

reg("__fmt_hex_upper", 1, (args) =>
  vstring(asInt(args[0]).toString(16).toUpperCase()));

reg("__fmt_oct", 1, (args) =>
  vstring(asInt(args[0]).toString(8)));

reg("__fmt_bin", 1, (args) =>
  vstring(asInt(args[0]).toString(2)));

reg("__fmt_zero_pad", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padStart(width, "0"));
});

reg("__fmt_pad_left", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padStart(width, " "));
});

reg("__fmt_pad_right", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padEnd(width, " "));
});

// Copy (continuation)
reg("copy", 1, (args) => {
  const cont = asContinuation(args[0]);
  return {
    tag: "continuation",
    fiber: copyFiber(cont.fiber),
    returnHandler: cont.returnHandler,
    opHandlers: cont.opHandlers,
    used: false,
  };
});

// --- Num class instances ---

reg("num_add_int", 2, (args) =>
  vint(asInt(args[0]) + asInt(args[1])));
reg("num_sub_int", 2, (args) =>
  vint(asInt(args[0]) - asInt(args[1])));
reg("num_mul_int", 2, (args) =>
  vint(asInt(args[0]) * asInt(args[1])));
reg("num_div_int", 2, (args) => {
  const b = asInt(args[1]);
  if (b === 0) error("division by zero");
  return vint(Math.trunc(asInt(args[0]) / b));
});
reg("num_neg_int", 1, (args) =>
  vint(-asInt(args[0])));

reg("num_add_float", 2, (args) =>
  vfloat(asFloat(args[0]) + asFloat(args[1])));
reg("num_sub_float", 2, (args) =>
  vfloat(asFloat(args[0]) - asFloat(args[1])));
reg("num_mul_float", 2, (args) =>
  vfloat(asFloat(args[0]) * asFloat(args[1])));
reg("num_div_float", 2, (args) =>
  vfloat(asFloat(args[0]) / asFloat(args[1])));
reg("num_neg_float", 1, (args) =>
  vfloat(-asFloat(args[0])));

// --- Eq class instances ---

reg("eq_int", 2, (args) =>
  vbool(asInt(args[0]) === asInt(args[1])));
reg("neq_int", 2, (args) =>
  vbool(asInt(args[0]) !== asInt(args[1])));

reg("eq_float", 2, (args) =>
  vbool(asFloat(args[0]) === asFloat(args[1])));
reg("neq_float", 2, (args) =>
  vbool(asFloat(args[0]) !== asFloat(args[1])));

reg("eq_string", 2, (args) =>
  vbool(asString(args[0]) === asString(args[1])));
reg("neq_string", 2, (args) =>
  vbool(asString(args[0]) !== asString(args[1])));

reg("eq_bool", 2, (args) =>
  vbool(asBool(args[0]) === asBool(args[1])));
reg("neq_bool", 2, (args) =>
  vbool(asBool(args[0]) !== asBool(args[1])));

reg("eq_byte", 2, (args) =>
  vbool(asByte(args[0]) === asByte(args[1])));
reg("neq_byte", 2, (args) =>
  vbool(asByte(args[0]) !== asByte(args[1])));

reg("eq_rune", 2, (args) =>
  vbool(asRune(args[0]) === asRune(args[1])));
reg("neq_rune", 2, (args) =>
  vbool(asRune(args[0]) !== asRune(args[1])));

// --- Ord class instances ---

reg("lt_int", 2, (args) =>
  vbool(asInt(args[0]) < asInt(args[1])));
reg("gt_int", 2, (args) =>
  vbool(asInt(args[0]) > asInt(args[1])));
reg("le_int", 2, (args) =>
  vbool(asInt(args[0]) <= asInt(args[1])));
reg("ge_int", 2, (args) =>
  vbool(asInt(args[0]) >= asInt(args[1])));

reg("lt_float", 2, (args) =>
  vbool(asFloat(args[0]) < asFloat(args[1])));
reg("gt_float", 2, (args) =>
  vbool(asFloat(args[0]) > asFloat(args[1])));
reg("le_float", 2, (args) =>
  vbool(asFloat(args[0]) <= asFloat(args[1])));
reg("ge_float", 2, (args) =>
  vbool(asFloat(args[0]) >= asFloat(args[1])));

reg("lt_string", 2, (args) =>
  vbool(asString(args[0]) < asString(args[1])));
reg("gt_string", 2, (args) =>
  vbool(asString(args[0]) > asString(args[1])));
reg("le_string", 2, (args) =>
  vbool(asString(args[0]) <= asString(args[1])));
reg("ge_string", 2, (args) =>
  vbool(asString(args[0]) >= asString(args[1])));

reg("lt_byte", 2, (args) =>
  vbool(asByte(args[0]) < asByte(args[1])));
reg("gt_byte", 2, (args) =>
  vbool(asByte(args[0]) > asByte(args[1])));
reg("le_byte", 2, (args) =>
  vbool(asByte(args[0]) <= asByte(args[1])));
reg("ge_byte", 2, (args) =>
  vbool(asByte(args[0]) >= asByte(args[1])));

reg("lt_rune", 2, (args) =>
  vbool(asRune(args[0]) < asRune(args[1])));
reg("gt_rune", 2, (args) =>
  vbool(asRune(args[0]) > asRune(args[1])));
reg("le_rune", 2, (args) =>
  vbool(asRune(args[0]) <= asRune(args[1])));
reg("ge_rune", 2, (args) =>
  vbool(asRune(args[0]) >= asRune(args[1])));

// --- Bitwise class instances ---

reg("band_int", 2, (args) =>
  vint(asInt(args[0]) & asInt(args[1])));
reg("bor_int", 2, (args) =>
  vint(asInt(args[0]) | asInt(args[1])));
reg("bxor_int", 2, (args) =>
  vint(asInt(args[0]) ^ asInt(args[1])));
reg("bshl_int", 2, (args) =>
  vint(asInt(args[0]) << asInt(args[1])));
reg("bshr_int", 2, (args) =>
  vint(asInt(args[0]) >>> asInt(args[1])));
reg("bnot_int", 1, (args) =>
  vint(~asInt(args[0])));

// --- Show class instances ---

reg("show_int", 1, (args) =>
  vstring(String(asInt(args[0]))));

reg("show_float", 1, (args) =>
  vstring(formatFloat(asFloat(args[0]))));

reg("show_bool", 1, (args) =>
  vstring(asBool(args[0]) ? "true" : "false"));

reg("show_string", 1, (args) => args[0]);

reg("show_unit", 1, () => vstring("()"));

reg("show_byte", 1, (args) =>
  vstring("#" + asByte(args[0]).toString(16).padStart(2, "0")));

reg("show_rune", 1, (args) =>
  vstring(ppValue(args[0])));

reg("show_map", 1, (args) =>
  vstring(ppValue(args[0])));

// --- Map class instances ---

reg("map_of_list", 1, (args) => {
  const lst = asList(args[0]);
  const pairs = lst.map((v) => {
    const t = asTuple(v);
    return [t[0], t[1]];
  });
  return vmap(pairs);
});

reg("map_get", 2, (args) => {
  const key = args[0];
  const pairs = asMap(args[1]);
  const entry = pairs.find(([k]) => valuesEqual(k, key));
  if (entry) return vvariant(1, "Some", entry[1]);
  return vvariant(0, "None", null);
});

reg("map_set", 3, (args) => {
  const k = args[0], v = args[1];
  const pairs = asMap(args[2]);
  const updated = [[k, v], ...pairs.filter(([k2]) => !valuesEqual(k2, k))];
  return vmap(updated);
});

reg("map_has", 2, (args) => {
  const key = args[0];
  const pairs = asMap(args[1]);
  return vbool(pairs.some(([k]) => valuesEqual(k, key)));
});

reg("map_remove", 2, (args) => {
  const key = args[0];
  const pairs = asMap(args[1]);
  return vmap(pairs.filter(([k]) => !valuesEqual(k, key)));
});

reg("map_size", 1, (args) =>
  vint(asMap(args[0]).length));

reg("map_keys", 1, (args) =>
  vlist(asMap(args[0]).map(([k]) => k)));

reg("map_values", 1, (args) =>
  vlist(asMap(args[0]).map(([, v]) => v)));

reg("map_to_list", 1, (args) =>
  vlist(asMap(args[0]).map(([k, v]) => vtuple([k, v]))));

// --- String module (std.ml register_string) ---

reg("String.length", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return vint(bytes.length);
});

reg("String.sub", 3, (args) => {
  const s = asString(args[0]);
  const bytes = stringToUtf8Bytes(s);
  const start = asInt(args[1]);
  const len = asInt(args[2]);
  if (start < 0 || len < 0 || start + len > bytes.length)
    error(`String.sub: index out of bounds`);
  return vstring(utf8BytesToString(bytes.slice(start, start + len)));
});

reg("String.split", 2, (args) => {
  const sep = asString(args[0]);
  const s = asString(args[1]);
  const parts = s.split(sep);
  return vlist(parts.map(vstring));
});

reg("String.trim", 1, (args) =>
  vstring(asString(args[0]).trim()));

reg("String.starts_with", 2, (args) => {
  const prefix = asString(args[0]);
  const s = asString(args[1]);
  return vbool(s.startsWith(prefix));
});

reg("String.contains", 2, (args) => {
  const sub = asString(args[0]);
  const s = asString(args[1]);
  return vbool(s.includes(sub));
});

reg("String.replace", 3, (args) => {
  const old = asString(args[0]);
  const rep = asString(args[1]);
  const s = asString(args[2]);
  return vstring(s.split(old).join(rep));
});

reg("String.to_int", 1, (args) => {
  const s = asString(args[0]);
  const n = parseInt(s, 10);
  if (isNaN(n) || String(n) !== s)
    return vvariant(0, "None", null);
  return vvariant(1, "Some", vint(n));
});

reg("String.to_float", 1, (args) => {
  const s = asString(args[0]);
  const f = parseFloat(s);
  if (isNaN(f))
    return vvariant(0, "None", null);
  return vvariant(1, "Some", vfloat(f));
});

reg("String.uppercase", 1, (args) =>
  vstring(asString(args[0]).toUpperCase()));

reg("String.lowercase", 1, (args) =>
  vstring(asString(args[0]).toLowerCase()));

reg("String.get", 2, (args) => {
  const s = asString(args[0]);
  const idx = asInt(args[1]);
  const bytes = stringToUtf8Bytes(s);
  if (idx < 0 || idx >= bytes.length)
    error(`String.get: index ${idx} out of bounds (length ${bytes.length})`);
  return vbyte(bytes[idx]);
});

reg("String.to_bytes", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return vlist(Array.from(bytes).map(vbyte));
});

reg("String.of_bytes", 1, (args) => {
  const lst = asList(args[0]);
  const bytes = new Uint8Array(lst.map(asByte));
  return vstring(utf8BytesToString(bytes));
});

reg("String.to_byte_array", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return varray(Array.from(bytes).map(vbyte));
});

reg("String.of_byte_array", 1, (args) => {
  const arr = asArray(args[0]);
  const bytes = new Uint8Array(arr.map(asByte));
  return vstring(utf8BytesToString(bytes));
});

reg("String.to_runes", 1, (args) => {
  const s = asString(args[0]);
  const runes = [];
  for (const ch of s) {
    runes.push(vrune(ch.codePointAt(0)));
  }
  return vlist(runes);
});

reg("String.of_runes", 1, (args) => {
  const lst = asList(args[0]);
  return vstring(lst.map((r) => runeToUtf8(asRune(r))).join(""));
});

reg("String.get_rune", 2, (args) => {
  const s = asString(args[0]);
  const idx = asInt(args[1]);
  const chars = [...s]; // iterate by codepoints
  if (idx < 0 || idx >= chars.length)
    error(`String.get_rune: index ${idx} out of bounds (length ${chars.length})`);
  return vrune(chars[idx].codePointAt(0));
});

reg("String.of_byte", 1, (args) => {
  const b = asByte(args[0]);
  return vstring(String.fromCharCode(b));
});

reg("String.rune_length", 1, (args) => {
  const s = asString(args[0]);
  return vint([...s].length);
});

reg("String.make", 2, (args) => {
  const n = asInt(args[0]);
  const b = asByte(args[1]);
  return vstring(String.fromCharCode(b).repeat(n));
});

reg("String.index_opt", 2, (args) => {
  const s = asString(args[0]);
  const b = asByte(args[1]);
  const bytes = stringToUtf8Bytes(s);
  const idx = bytes.indexOf(b);
  return idx >= 0 ? vvariant(1, "Some", vint(idx)) : vvariant(0, "None", null);
});

reg("String.rindex_opt", 2, (args) => {
  const s = asString(args[0]);
  const b = asByte(args[1]);
  const bytes = stringToUtf8Bytes(s);
  const idx = bytes.lastIndexOf(b);
  return idx >= 0 ? vvariant(1, "Some", vint(idx)) : vvariant(0, "None", null);
});

reg("String.concat", 2, (args) => {
  const sep = asString(args[0]);
  const lst = asList(args[1]);
  const strs = lst.map(v => asString(v));
  return vstring(strs.join(sep));
});

// --- Array module (std.ml register_array) ---

reg("Array.make", 2, (args) => {
  const n = asInt(args[0]);
  const v = args[1];
  return varray(new Array(n).fill(v));
});

reg("Array.get", 2, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  return arr[idx];
});

reg("Array.set", 3, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  const v = args[2];
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  arr[idx] = v;
  return VUNIT;
});

reg("Array.length", 1, (args) =>
  vint(asArray(args[0]).length));

reg("Array.to_list", 1, (args) =>
  vlist(Array.from(asArray(args[0]))));

reg("Array.of_list", 1, (args) =>
  varray(asList(args[0]).slice()));

reg("Array.copy", 1, (args) =>
  varray(asArray(args[0]).slice()));

reg("Array.sub", 3, (args) => {
  const arr = asArray(args[0]);
  const start = asInt(args[1]);
  const len = asInt(args[2]);
  return varray(arr.slice(start, start + len));
});

// --- IO module (browser stubs, configurable via globalThis) ---

reg("IO.read_file", 1, (args) => {
  if (typeof globalThis._vmReadFile === "function") {
    return vstring(globalThis._vmReadFile(asString(args[0])));
  }
  error("IO.read_file not supported in browser");
});
reg("IO.write_file", 2, () => { error("IO.write_file not supported in browser"); });
reg("IO.append_file", 2, () => { error("IO.append_file not supported in browser"); });
reg("IO.read_line", 1, () => { error("IO.read_line not supported in browser"); });
reg("IO.file_exists", 1, () => vbool(false));

// --- Sys module (browser stubs, configurable via globalThis) ---

reg("Sys.args", 1, () => {
  if (globalThis._vmArgs) {
    return vlist(globalThis._vmArgs.map(vstring));
  }
  return vlist([]);
});
reg("Sys.getenv", 1, () => vvariant(0, "None", null));
reg("Sys.exit", 1, () => { error("Sys.exit not supported in browser"); });
reg("Sys.time", 1, () => vfloat(performance.now() / 1000));

// --- Runtime.eval/eval_file (stubs for JS) ---

reg("Runtime.eval", 1, () => {
  error("Runtime.eval not supported in JS VM");
});

reg("Runtime.eval_file", 1, () => {
  error("Runtime.eval_file not supported in JS VM");
});

// --- Helper: OCaml %g-like float formatting ---
function formatFloat(f) {
  if (!isFinite(f)) {
    if (f !== f) return "nan";
    return f > 0 ? "inf" : "-inf";
  }
  // %g uses shortest of %e and %f with 6 significant digits, trims trailing zeros
  let s = f.toPrecision(6);
  // Remove trailing zeros after decimal point
  if (s.includes('.')) {
    s = s.replace(/0+$/, '');
    s = s.replace(/\.$/, '');
  }
  // Handle exponential notation
  if (s.includes('e+')) s = s.replace('e+0', 'e+').replace('e+', 'e+');
  if (s.includes('e-')) s = s.replace('e-0', 'e-');
  // Match OCaml's %g: -0 -> -0
  if (Object.is(f, -0)) return "-0";
  return s;
}



// ---- loader.js ----
// Loader: deserializes JSON bundle and runs it



function deserializeValue(j) {
  switch (j.t) {
    case "i": return vint(j.v);
    case "f": return vfloat(j.v);
    case "b": return vbool(j.v);
    case "s": return vstring(j.v);
    case "y": return vbyte(j.v);
    case "r": return vrune(j.v);
    case "u": return VUNIT;
    case "p": return vproto(deserializePrototype(j.v));
    case "T": return vtuple(j.v.map(deserializeValue));
    case "L": return vlist(j.v.map(deserializeValue));
    case "V": {
      const payload = j.payload === null ? null : deserializeValue(j.payload);
      return vvariant(j.tag, j.name, payload);
    }
    default:
      error(`unknown value type: ${j.t}`);
  }
}

function deserializePrototype(j) {
  return {
    name: j.name,
    arity: j.arity,
    num_locals: j.num_locals,
    code: j.code,
    constants: j.constants.map(deserializeValue),
    line_table: j.line_table || [],
  };
}

function makeExternal(name, arity, fn) {
  return vexternal(name, arity, (args) => fn(args));
}

function registerBuiltins(vmInst, bundle) {
  const nativeGlobals = bundle.native_globals;
  for (const [idxStr, info] of Object.entries(nativeGlobals)) {
    const idx = parseInt(idxStr, 10);
    if (info.type === "external") {
      const b = builtins[info.name];
      if (!b) {
        // Skip unknown builtins (e.g. Runtime.eval)
        // Register a stub that errors
        vmInst.globals.set(idx, makeExternal(info.name, info.arity, () => {
          error(`unimplemented builtin: ${info.name}`);
        }));
        continue;
      }
      vmInst.globals.set(idx, makeExternal(info.name, b.arity, b.fn));
    } else if (info.type === "dict") {
      // Typeclass dictionary: record of externals
      const fields = Object.entries(info.fields).map(([fieldName, fieldInfo]) => {
        const b = builtins[fieldInfo.name];
        if (!b) {
          return [fieldName, makeExternal(fieldInfo.name, fieldInfo.arity, () => {
            error(`unimplemented builtin: ${fieldInfo.name}`);
          })];
        }
        return [fieldName, makeExternal(fieldInfo.name, b.arity, b.fn)];
      });
      vmInst.globals.set(idx, vrecord(fields));
    }
  }
}

function loadBundle(jsonString) {
  const bundle = JSON.parse(jsonString);
  const globalNames = bundle.global_names;
  const vmInst = createVM(globalNames);

  // Register native builtins
  registerBuiltins(vmInst, bundle);

  // Run setup prototypes (rebuild source-compiled stdlib)
  for (const setupJson of bundle.setup) {
    const proto = deserializePrototype(setupJson);
    executeProto(vmInst, proto);
  }

  // Run main prototype
  const mainProto = deserializePrototype(bundle.main);
  return executeProto(vmInst, mainProto);
}



// ---- Public API ----
global.MiniML = {
  loadBundle: loadBundle,
  ppValue: ppValue,
  RuntimeError: RuntimeError,
  VUNIT: VUNIT,
};

})(typeof window !== "undefined" ? window : globalThis);
