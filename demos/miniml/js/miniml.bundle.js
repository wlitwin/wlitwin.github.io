// MiniML VM - browser bundle (generated by browser.js)
(function(global) {
"use strict";

// ---- vm.js ----
//# allFunctionsCallOnLoad
// VM core â€” direct port of lib/vm.ml

class RuntimeError extends Error {
  constructor(msg) { super(msg); this.name = "RuntimeError"; }
}

function error(msg) { throw new RuntimeError(msg); }

// --- Value constructors ---
const VUNIT = { tag: "unit" };
const vint = (v) => ({ tag: "int", v });
const vfloat = (v) => ({ tag: "float", v });
const vbool = (v) => v ? VTRUE : VFALSE;
const VTRUE = { tag: "bool", v: true };
const VFALSE = { tag: "bool", v: false };
const vstring = (v) => ({ tag: "string", v });
const vbyte = (v) => ({ tag: "byte", v: v & 0xFF });
const vrune = (v) => ({ tag: "rune", v });
const vtuple = (vs) => ({ tag: "tuple", v: vs });
// Lists use linked cons cells: {tag:"list", hd, tl} for cons, VNIL for nil
const VNIL = Object.freeze({ tag: "list" });
function vlist(arr) {
  let result = VNIL;
  for (let i = arr.length - 1; i >= 0; i--) result = { tag: "list", hd: arr[i], tl: result };
  return result;
}
const vrecord = (fields) => ({ tag: "record", v: fields }); // fields: [[name, val], ...]
const vvariant = (tagN, name, payload) => ({ tag: "variant", tagN, name, payload });
const vclosure = (proto, upvalues) => ({ tag: "closure", proto, upvalues });
const vpartial = (closure, args) => ({ tag: "partial", closure, args });
const vexternal = (name, arity, fn, args) => ({ tag: "external", name, arity, fn, args: args || [] });
const vcontinuation = (fiber, returnHandler, opHandlers, bodyFiber, intermediateHandlers) =>
  ({ tag: "continuation", fiber, returnHandler, opHandlers,
     bodyFiber: bodyFiber || fiber, intermediateHandlers: intermediateHandlers || [],
     used: false });
const vref = (v) => ({ tag: "ref", v: [v] }); // use array for mutability
const vmap = (pairs) => ({ tag: "map", v: pairs }); // pairs: [[k, v], ...]
const varray = (elems) => ({ tag: "array", v: elems });
const vproto = (p) => ({ tag: "proto", v: p });

// --- Value accessors ---
function asInt(v) { if (v.tag === "int") return v.v; error(`expected int, got ${ppValue(v)}`); }
function asFloat(v) { if (v.tag === "float") return v.v; error(`expected float, got ${ppValue(v)}`); }
function asBool(v) { if (v.tag === "bool") return v.v; error(`expected bool, got ${ppValue(v)}`); }
function asString(v) { if (v.tag === "string") return v.v; error(`expected string, got ${ppValue(v)}`); }
function asClosure(v) { if (v.tag === "closure") return v; error(`expected function, got ${ppValue(v)}`); }
function asTuple(v) { if (v.tag === "tuple") return v.v; error(`expected tuple, got ${ppValue(v)}`); }
function asRecord(v) { if (v.tag === "record") return v.v; error(`expected record, got ${ppValue(v)}`); }
function asList(v) { if (v.tag === "list") return v; error(`expected list, got ${ppValue(v)}`); }
function listToArray(v) {
  const result = [];
  let cur = asList(v);
  while ("hd" in cur) { result.push(cur.hd); cur = cur.tl; }
  return result;
}
function asVariant(v) { if (v.tag === "variant") return v; error(`expected variant, got ${ppValue(v)}`); }
function asContinuation(v) { if (v.tag === "continuation") return v; error(`expected continuation, got ${ppValue(v)}`); }
function asByte(v) { if (v.tag === "byte") return v.v; error(`expected byte, got ${ppValue(v)}`); }
function asRune(v) { if (v.tag === "rune") return v.v; error(`expected rune, got ${ppValue(v)}`); }
function asMap(v) { if (v.tag === "map") return v.v; error(`expected map, got ${ppValue(v)}`); }
function asArray(v) { if (v.tag === "array") return v.v; error(`expected array, got ${ppValue(v)}`); }

// --- Structural equality (matches vm.ml values_equal) ---
function valuesEqual(a, b) {
  if (a === b) return true;
  if (a.tag !== b.tag) return false;
  switch (a.tag) {
    case "int": case "float": case "bool": case "byte": case "rune":
      return a.v === b.v;
    case "string":
      return a.v === b.v;
    case "unit":
      return true;
    case "tuple":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) if (!valuesEqual(a.v[i], b.v[i])) return false;
      return true;
    case "list": {
      let ca = a, cb = b;
      while ("hd" in ca && "hd" in cb) {
        if (!valuesEqual(ca.hd, cb.hd)) return false;
        ca = ca.tl; cb = cb.tl;
      }
      return !("hd" in ca) && !("hd" in cb);
    }
    case "variant":
      if (a.tagN !== b.tagN) return false;
      if (a.payload === null && b.payload === null) return true;
      if (a.payload !== null && b.payload !== null) return valuesEqual(a.payload, b.payload);
      return false;
    case "record":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) {
        if (a.v[i][0] !== b.v[i][0] || !valuesEqual(a.v[i][1], b.v[i][1])) return false;
      }
      return true;
    case "array":
      if (a.v.length !== b.v.length) return false;
      for (let i = 0; i < a.v.length; i++) if (!valuesEqual(a.v[i], b.v[i])) return false;
      return true;
    default:
      return false;
  }
}

// --- Pretty-print (matches bytecode.ml pp_value) ---
function runeToUtf8(cp) {
  if (cp < 0x80) return String.fromCharCode(cp);
  if (cp < 0x800) return String.fromCharCode(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
  if (cp < 0x10000)
    return String.fromCharCode(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
  return String.fromCodePoint(cp);
}

function ppValue(v) {
  switch (v.tag) {
    case "int": return String(v.v);
    case "float": {
      let s = String(v.v);
      if (!s.includes('.') && !s.includes('e') && !s.includes('E') && isFinite(v.v)) s += ".";
      return s;
    }
    case "bool": return v.v ? "true" : "false";
    case "string": return v.v;
    case "byte": return "#" + v.v.toString(16).padStart(2, '0');
    case "rune": return "'" + runeToUtf8(v.v) + "'";
    case "unit": return "()";
    case "tuple": return "(" + v.v.map(ppValue).join(", ") + ")";
    case "list": {
      const elems = [];
      let cur = v;
      while ("hd" in cur) { elems.push(ppValue(cur.hd)); cur = cur.tl; }
      return "[" + elems.join("; ") + "]";
    }
    case "record":
      return "{ " + v.v.map(([n, val]) => n + " = " + ppValue(val)).join("; ") + " }";
    case "variant":
      if (v.payload === null) return v.name;
      const pv = ppValue(v.payload);
      if (v.payload.tag === "tuple" || (v.payload.tag === "variant" && v.payload.payload !== null))
        return v.name + " (" + pv + ")";
      return v.name + " " + pv;
    case "closure": return "<fun>";
    case "partial": return "<fun>";
    case "external":
      if (v.args.length === 0) return `<external:${v.name}>`;
      return "<fun>";
    case "proto": return `<proto:${v.v.name}>`;
    case "continuation": return "<continuation>";
    case "ref": return `ref(${ppValue(v.v[0])})`;
    case "map": {
      const isSet = v.v.every(([_, val]) => val.tag === "unit");
      if (isSet) return "#{" + v.v.map(([k]) => ppValue(k)).join("; ") + "}";
      return "#{" + v.v.map(([k, val]) => ppValue(k) + ": " + ppValue(val)).join("; ") + "}";
    }
    case "array": return "#[" + v.v.map(ppValue).join("; ") + "]";
    default: return "<unknown>";
  }
}

// --- Fiber ---
const STACK_SIZE = 65536;

function makeFiber() {
  return { stack: new Array(STACK_SIZE).fill(VUNIT), sp: 0, frames: [], extraArgs: [] };
}

function copyFiber(f) {
  const newStack = f.stack.slice();
  const newFrames = f.frames.map(fr => ({
    closure: fr.closure,
    ip: fr.ip,
    baseSp: fr.baseSp,
  }));
  return { stack: newStack, sp: f.sp, frames: newFrames, extraArgs: f.extraArgs.map(a => a.slice()) };
}

// --- Top-level helper functions ---
function findHandler(vm, opName) {
  for (let i = vm.handlerStack.length - 1; i >= 0; i--) {
    const he = vm.handlerStack[i];
    for (const [name] of he.ops) {
      if (name === opName) return he;
    }
  }
  return null;
}

function findHandlerForFiber(vm, f) {
  for (const he of vm.handlerStack) {
    if (he.bodyFiber === f) return he;
  }
  return null;
}

function removeHandler(vm, he) {
  vm.handlerStack = vm.handlerStack.filter(h => h !== he);
}

function internalCall(fiber, cls, arg) {
  const base = fiber.sp;
  const numLocals = cls.proto.num_locals;
  fiber.stack.fill(VUNIT, base, base + numLocals);
  fiber.stack[base] = arg;
  fiber.sp = base + numLocals;
  fiber.frames.push({ closure: cls, ip: 0, baseSp: base });
}

// --- Opcode profiling (toggle with vm.profile = true) ---
const OP_COUNTS = new Uint32Array(85);

function resetProfile() { OP_COUNTS.fill(0); }

function dumpProfile(opcodeNames) {
  const entries = [];
  for (let i = 0; i < OP_COUNTS.length; i++) {
    if (OP_COUNTS[i] > 0) entries.push([i, OP_COUNTS[i]]);
  }
  entries.sort((a, b) => b[1] - a[1]);
  const total = entries.reduce((s, e) => s + e[1], 0);
  console.log(`\n--- opcode profile (${total.toLocaleString()} total) ---`);
  for (const [op, count] of entries.slice(0, 20)) {
    const name = (opcodeNames && opcodeNames[op]) || String(op);
    const pct = (count / total * 100).toFixed(1);
    console.log(`  ${name.padEnd(22)} ${count.toLocaleString().padStart(12)}  (${pct}%)`);
  }
}

// --- Multi-arity call helpers ---
function callWithArgs(vm, fiber, fnVal, args) {
  // Returns true if a frame was entered, false if result was pushed to stack
  if (fnVal.tag === "closure") {
    const arity = fnVal.proto.arity;
    const n = args.length;
    if (n === arity) {
      const base = fiber.sp;
      const numLocals = fnVal.proto.num_locals;
      fiber.stack.fill(VUNIT, base, base + numLocals);
      for (let i = 0; i < n; i++) fiber.stack[base + i] = args[i];
      fiber.sp = base + numLocals;
      fiber.frames.push({ closure: fnVal, ip: 0, baseSp: base });
      return true;
    } else if (n < arity) {
      fiber.stack[fiber.sp++] = vpartial(fnVal, args);
      return false;
    } else {
      const useArgs = args.slice(0, arity);
      const extra = args.slice(arity);
      fiber.extraArgs.push(extra);
      const base = fiber.sp;
      const numLocals = fnVal.proto.num_locals;
      fiber.stack.fill(VUNIT, base, base + numLocals);
      for (let i = 0; i < arity; i++) fiber.stack[base + i] = useArgs[i];
      fiber.sp = base + numLocals;
      fiber.frames.push({ closure: fnVal, ip: 0, baseSp: base });
      return true;
    }
  } else if (fnVal.tag === "partial") {
    return callWithArgs(vm, fiber, fnVal.closure, fnVal.args.concat(args));
  } else if (fnVal.tag === "external") {
    const all = fnVal.args.concat(args);
    if (all.length >= fnVal.arity) {
      const useArgs = all.slice(0, fnVal.arity);
      const remaining = all.slice(fnVal.arity);
      const result = fnVal.fn(useArgs);
      if (remaining.length === 0) { fiber.stack[fiber.sp++] = result; return false; }
      return callWithArgs(vm, fiber, result, remaining);
    } else {
      fiber.stack[fiber.sp++] = vexternal(fnVal.name, fnVal.arity, fnVal.fn, all);
      return false;
    }
  } else {
    error(`CALL_N: expected function, got ${ppValue(fnVal)}`);
  }
}

function processExtraArgs(vm, fiber, result) {
  // Returns [result, enteredFrame]
  while (fiber.extraArgs.length > 0) {
    const pending = fiber.extraArgs[fiber.extraArgs.length - 1];
    fiber.extraArgs.pop();
    if (result.tag === "closure") {
      const arity = result.proto.arity;
      const n = pending.length;
      if (n >= arity) {
        const useArgs = pending.slice(0, arity);
        const remaining = pending.slice(arity);
        if (remaining.length > 0) fiber.extraArgs.push(remaining);
        const base = fiber.sp;
        const numLocals = result.proto.num_locals;
        fiber.stack.fill(VUNIT, base, base + numLocals);
        for (let i = 0; i < arity; i++) fiber.stack[base + i] = useArgs[i];
        fiber.sp = base + numLocals;
        fiber.frames.push({ closure: result, ip: 0, baseSp: base });
        return [result, true];
      } else {
        // Not enough args in this batch
        result = vpartial(result, pending);
        // continue to next batch
      }
    } else if (result.tag === "partial") {
      fiber.extraArgs.push(result.args.concat(pending));
      result = result.closure;
      // re-process
    } else if (result.tag === "external") {
      const all = result.args.concat(pending);
      if (all.length >= result.arity) {
        const useArgs = all.slice(0, result.arity);
        const remaining = all.slice(result.arity);
        if (remaining.length > 0) fiber.extraArgs.push(remaining);
        result = result.fn(useArgs);
        // continue - result might be callable
      } else {
        result = vexternal(result.name, result.arity, result.fn, all);
        // continue to next batch
      }
    } else {
      error(`expected function in over-application, got ${ppValue(result)}`);
    }
  }
  return [result, false];
}

// --- VM dispatch loop ---
function run(vm) {
  let fiber = vm.currentFiber;
  // const profiling = vm.profile;

  while (true) {
    const f = fiber.frames[fiber.frames.length - 1];
    const op = f.closure.proto.code[f.ip++];
    // if (profiling) OP_COUNTS[op[0]]++;

    switch (op[0]) {
      case 0: // CONST
        fiber.stack[fiber.sp++] = f.closure.proto.constants[op[1]];
        break;
      case 1: // POP
        fiber.sp--;
        break;
      case 2: // DUP
        fiber.stack[fiber.sp] = fiber.stack[fiber.sp - 1];
        fiber.sp++;
        break;
      case 3: // GET_LOCAL
        fiber.stack[fiber.sp++] = fiber.stack[f.baseSp + op[1]];
        break;
      case 4: // SET_LOCAL
        fiber.stack[f.baseSp + op[1]] = fiber.stack[--fiber.sp];
        break;
      case 5: // GET_UPVALUE
        fiber.stack[fiber.sp++] = f.closure.upvalues[op[1]];
        break;
      case 6: // SET_UPVALUE
        f.closure.upvalues[op[1]] = fiber.stack[--fiber.sp];
        break;
      case 7: // MAKE_REF
        fiber.stack[fiber.sp - 1] = vref(fiber.stack[fiber.sp - 1]);
        break;
      case 8: { // DEREF
        const r = fiber.stack[fiber.sp - 1];
        if (r.tag !== "ref") error("DEREF on non-ref value");
        fiber.stack[fiber.sp - 1] = r.v[0];
        break;
      }
      case 9: { // SET_REF
        const r = fiber.stack[--fiber.sp];
        const v = fiber.stack[--fiber.sp];
        if (r.tag !== "ref") error("SET_REF on non-ref value");
        r.v[0] = v;
        break;
      }
      case 10: { // GET_GLOBAL
        const idx = op[1];
        const v = vm.globals.get(idx);
        if (v === undefined) {
          const name = idx < vm.globalNames.length ? vm.globalNames[idx] : "?";
          error(`undefined global: ${name}`);
        }
        fiber.stack[fiber.sp++] = v;
        break;
      }
      case 11: // SET_GLOBAL
        vm.globals.set(op[1], fiber.stack[--fiber.sp]);
        break;
      case 12: // DEF_GLOBAL
        vm.globals.set(op[1], fiber.stack[--fiber.sp]);
        break;
      case 13: { // ADD
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) + asInt(b));
        break;
      }
      case 14: { // SUB
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) - asInt(b));
        break;
      }
      case 15: { // MUL
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) * asInt(b));
        break;
      }
      case 16: { // DIV
        const b = fiber.stack[--fiber.sp];
        const bv = asInt(b);
        if (bv === 0) error("division by zero");
        fiber.stack[fiber.sp - 1] = vint(Math.trunc(asInt(fiber.stack[fiber.sp - 1]) / bv));
        break;
      }
      case 17: { // MOD
        const b = fiber.stack[--fiber.sp];
        const bv = asInt(b);
        if (bv === 0) error("modulo by zero");
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) % bv);
        break;
      }
      case 18: // NEG
        fiber.stack[fiber.sp - 1] = vint(-asInt(fiber.stack[fiber.sp - 1]));
        break;
      case 19: { // FADD
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vfloat(asFloat(fiber.stack[fiber.sp - 1]) + asFloat(b));
        break;
      }
      case 20: { // FSUB
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vfloat(asFloat(fiber.stack[fiber.sp - 1]) - asFloat(b));
        break;
      }
      case 21: { // FMUL
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vfloat(asFloat(fiber.stack[fiber.sp - 1]) * asFloat(b));
        break;
      }
      case 22: { // FDIV
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vfloat(asFloat(fiber.stack[fiber.sp - 1]) / asFloat(b));
        break;
      }
      case 23: // FNEG
        fiber.stack[fiber.sp - 1] = vfloat(-asFloat(fiber.stack[fiber.sp - 1]));
        break;
      case 24: { // EQ
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vbool(valuesEqual(fiber.stack[fiber.sp - 1], b));
        break;
      }
      case 25: { // NEQ
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vbool(!valuesEqual(fiber.stack[fiber.sp - 1], b));
        break;
      }
      case 26: { // LT
        const b = fiber.stack[--fiber.sp];
        const a = fiber.stack[fiber.sp - 1];
        let result;
        if (a.tag === "float" && b.tag === "float") result = a.v < b.v;
        else if (a.tag === "string" && b.tag === "string") result = a.v < b.v;
        else if (a.tag === "byte" && b.tag === "byte") result = a.v < b.v;
        else if (a.tag === "rune" && b.tag === "rune") result = a.v < b.v;
        else result = asInt(a) < asInt(b);
        fiber.stack[fiber.sp - 1] = vbool(result);
        break;
      }
      case 27: { // GT
        const b = fiber.stack[--fiber.sp];
        const a = fiber.stack[fiber.sp - 1];
        let result;
        if (a.tag === "float" && b.tag === "float") result = a.v > b.v;
        else if (a.tag === "string" && b.tag === "string") result = a.v > b.v;
        else if (a.tag === "byte" && b.tag === "byte") result = a.v > b.v;
        else if (a.tag === "rune" && b.tag === "rune") result = a.v > b.v;
        else result = asInt(a) > asInt(b);
        fiber.stack[fiber.sp - 1] = vbool(result);
        break;
      }
      case 28: { // LE
        const b = fiber.stack[--fiber.sp];
        const a = fiber.stack[fiber.sp - 1];
        let result;
        if (a.tag === "float" && b.tag === "float") result = a.v <= b.v;
        else if (a.tag === "string" && b.tag === "string") result = a.v <= b.v;
        else if (a.tag === "byte" && b.tag === "byte") result = a.v <= b.v;
        else if (a.tag === "rune" && b.tag === "rune") result = a.v <= b.v;
        else result = asInt(a) <= asInt(b);
        fiber.stack[fiber.sp - 1] = vbool(result);
        break;
      }
      case 29: { // GE
        const b = fiber.stack[--fiber.sp];
        const a = fiber.stack[fiber.sp - 1];
        let result;
        if (a.tag === "float" && b.tag === "float") result = a.v >= b.v;
        else if (a.tag === "string" && b.tag === "string") result = a.v >= b.v;
        else if (a.tag === "byte" && b.tag === "byte") result = a.v >= b.v;
        else if (a.tag === "rune" && b.tag === "rune") result = a.v >= b.v;
        else result = asInt(a) >= asInt(b);
        fiber.stack[fiber.sp - 1] = vbool(result);
        break;
      }
      case 30: // NOT
        fiber.stack[fiber.sp - 1] = vbool(!asBool(fiber.stack[fiber.sp - 1]));
        break;
      case 31: { // BAND
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) & asInt(b));
        break;
      }
      case 32: { // BOR
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) | asInt(b));
        break;
      }
      case 33: { // BXOR
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) ^ asInt(b));
        break;
      }
      case 34: // BNOT
        fiber.stack[fiber.sp - 1] = vint(~asInt(fiber.stack[fiber.sp - 1]));
        break;
      case 35: { // BSHL
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) << asInt(b));
        break;
      }
      case 36: { // BSHR
        const b = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp - 1] = vint(asInt(fiber.stack[fiber.sp - 1]) >>> asInt(b));
        break;
      }
      case 37: // JUMP
        f.ip = op[1];
        break;
      case 38: { // JUMP_IF_FALSE
        const v = fiber.stack[--fiber.sp];
        if (!asBool(v)) f.ip = op[1];
        break;
      }
      case 39: { // JUMP_IF_TRUE
        const v = fiber.stack[--fiber.sp];
        if (asBool(v)) f.ip = op[1];
        break;
      }
      case 40: { // CLOSURE
        const protoIdx = op[1];
        const captures = op[2];
        const fnProto = getProto(f.closure.proto, protoIdx);
        const upvalues = captures.map(cap => resolveCapture(fiber, f, cap));
        fiber.stack[fiber.sp++] = vclosure(fnProto, upvalues);
        break;
      }
      case 41: { // CLOSURE_REC
        const protoIdx = op[1];
        const captures = op[2];
        const selfIdx = op[3];
        const fnProto = getProto(f.closure.proto, protoIdx);
        const upvalues = captures.map(cap => resolveCapture(fiber, f, cap));
        const cls = vclosure(fnProto, upvalues);
        cls.upvalues[selfIdx] = cls; // circular reference for recursion
        fiber.stack[fiber.sp++] = cls;
        break;
      }
      case 42: { // CALL
        const arg = fiber.stack[--fiber.sp];
        const fnVal = fiber.stack[--fiber.sp];
        if (fnVal.tag === "closure") {
          if (fnVal.proto.arity === 1) {
            const base = fiber.sp;
            const numLocals = fnVal.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            fiber.stack[base] = arg;
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: fnVal, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal, [arg]);
          }
        } else if (fnVal.tag === "partial") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.closure.proto.arity) {
            const cls = fnVal.closure;
            const base = fiber.sp;
            const numLocals = cls.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            for (let i = 0; i < newArgs.length; i++) fiber.stack[base + i] = newArgs[i];
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: cls, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal.closure, newArgs);
          }
        } else if (fnVal.tag === "external") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.arity) {
            fiber.stack[fiber.sp++] = fnVal.fn(newArgs);
          } else {
            fiber.stack[fiber.sp++] = vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs);
          }
        } else {
          error(`expected function, got ${ppValue(fnVal)}`);
        }
        break;
      }
      case 43: { // TAIL_CALL
        const arg = fiber.stack[--fiber.sp];
        const fnVal = fiber.stack[--fiber.sp];
        let tailResult = null;
        let tailEntered = false;
        if (fnVal.tag === "closure") {
          if (fnVal.proto.arity === 1) {
            const currentBaseSp = f.baseSp;
            const numLocals = fnVal.proto.num_locals;
            fiber.stack.fill(VUNIT, currentBaseSp, currentBaseSp + numLocals);
            fiber.stack[currentBaseSp] = arg;
            fiber.sp = currentBaseSp + numLocals;
            fiber.frames[fiber.frames.length - 1] = { closure: fnVal, ip: 0, baseSp: currentBaseSp };
            tailEntered = true;
          } else {
            tailResult = vpartial(fnVal, [arg]);
          }
        } else if (fnVal.tag === "partial") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.closure.proto.arity) {
            const cls = fnVal.closure;
            const currentBaseSp = f.baseSp;
            const numLocals = cls.proto.num_locals;
            fiber.stack.fill(VUNIT, currentBaseSp, currentBaseSp + numLocals);
            for (let i = 0; i < newArgs.length; i++) fiber.stack[currentBaseSp + i] = newArgs[i];
            fiber.sp = currentBaseSp + numLocals;
            fiber.frames[fiber.frames.length - 1] = { closure: cls, ip: 0, baseSp: currentBaseSp };
            tailEntered = true;
          } else {
            tailResult = vpartial(fnVal.closure, newArgs);
          }
        } else if (fnVal.tag === "external") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.arity) {
            tailResult = fnVal.fn(newArgs);
          } else {
            tailResult = vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs);
          }
        } else {
          error(`expected function, got ${ppValue(fnVal)}`);
        }
        if (!tailEntered) {
          fiber.sp = f.baseSp;
          fiber.frames.pop();
          let result2 = tailResult;
          if (fiber.extraArgs.length > 0) {
            const [res, entered2] = processExtraArgs(vm, fiber, tailResult);
            result2 = res;
            if (entered2) break;
          }
          if (fiber.frames.length === 0) {
            const he = findHandlerForFiber(vm, fiber);
            if (he) {
              removeHandler(vm, he);
              fiber = he.parentFiber;
              vm.currentFiber = fiber;
              internalCall(fiber, asClosure(he.returnHandler), result2);
            } else {
              return result2;
            }
          } else {
            fiber.stack[fiber.sp++] = result2;
          }
        }
        break;
      }
      case 44: { // RETURN
        let result = fiber.stack[--fiber.sp];
        fiber.sp = fiber.frames[fiber.frames.length - 1].baseSp;
        fiber.frames.pop();
        if (fiber.extraArgs.length > 0) {
          const [res, entered] = processExtraArgs(vm, fiber, result);
          result = res;
          if (entered) break;
        }
        if (fiber.frames.length === 0) {
          const he = findHandlerForFiber(vm, fiber);
          if (he) {
            removeHandler(vm, he);
            fiber = he.parentFiber;
            vm.currentFiber = fiber;
            internalCall(fiber, asClosure(he.returnHandler), result);
          } else {
            return result;
          }
        } else {
          fiber.stack[fiber.sp++] = result;
        }
        break;
      }
      case 83: { // CALL_N
        const n = op[1];
        const args = new Array(n);
        for (let i = n - 1; i >= 0; i--) args[i] = fiber.stack[--fiber.sp];
        const fnVal83 = fiber.stack[--fiber.sp];
        callWithArgs(vm, fiber, fnVal83, args);
        break;
      }
      case 84: { // TAIL_CALL_N
        const n = op[1];
        const args = new Array(n);
        for (let i = n - 1; i >= 0; i--) args[i] = fiber.stack[--fiber.sp];
        const fnVal84 = fiber.stack[--fiber.sp];
        // Try to resolve the call
        let tcnEntered = false;
        let tcnResult = null;
        const resolve = (fn, remaining) => {
          if (fn.tag === "closure") {
            const arity = fn.proto.arity;
            const nArgs = remaining.length;
            if (nArgs === arity) {
              const baseSp = f.baseSp;
              const numLocals = fn.proto.num_locals;
              fiber.stack.fill(VUNIT, baseSp, baseSp + numLocals);
              for (let i = 0; i < nArgs; i++) fiber.stack[baseSp + i] = remaining[i];
              fiber.sp = baseSp + numLocals;
              fiber.frames[fiber.frames.length - 1] = { closure: fn, ip: 0, baseSp };
              tcnEntered = true;
            } else if (nArgs < arity) {
              tcnResult = vpartial(fn, remaining);
            } else {
              const useArgs = remaining.slice(0, arity);
              const extra = remaining.slice(arity);
              fiber.extraArgs.push(extra);
              const baseSp = f.baseSp;
              const numLocals = fn.proto.num_locals;
              fiber.stack.fill(VUNIT, baseSp, baseSp + numLocals);
              for (let i = 0; i < arity; i++) fiber.stack[baseSp + i] = useArgs[i];
              fiber.sp = baseSp + numLocals;
              fiber.frames[fiber.frames.length - 1] = { closure: fn, ip: 0, baseSp };
              tcnEntered = true;
            }
          } else if (fn.tag === "partial") {
            resolve(fn.closure, fn.args.concat(remaining));
          } else if (fn.tag === "external") {
            const all = fn.args.concat(remaining);
            if (all.length >= fn.arity) {
              const useArgs = all.slice(0, fn.arity);
              const rest = all.slice(fn.arity);
              const r = fn.fn(useArgs);
              if (rest.length === 0) tcnResult = r;
              else resolve(r, rest);
            } else {
              tcnResult = vexternal(fn.name, fn.arity, fn.fn, all);
            }
          } else {
            error(`TAIL_CALL_N: expected function, got ${ppValue(fn)}`);
          }
        };
        resolve(fnVal84, args);
        if (!tcnEntered) {
          fiber.sp = f.baseSp;
          fiber.frames.pop();
          let result2 = tcnResult;
          if (fiber.extraArgs.length > 0) {
            const [res, entered2] = processExtraArgs(vm, fiber, tcnResult);
            result2 = res;
            if (entered2) break;
          }
          if (fiber.frames.length === 0) {
            const he = findHandlerForFiber(vm, fiber);
            if (he) {
              removeHandler(vm, he);
              fiber = he.parentFiber;
              vm.currentFiber = fiber;
              internalCall(fiber, asClosure(he.returnHandler), result2);
            } else {
              return result2;
            }
          } else {
            fiber.stack[fiber.sp++] = result2;
          }
        }
        break;
      }
      case 48: { // MAKE_TUPLE
        const n = op[1];
        const values = new Array(n);
        for (let i = n - 1; i >= 0; i--) values[i] = fiber.stack[--fiber.sp];
        fiber.stack[fiber.sp++] = vtuple(values);
        break;
      }
      case 49: { // TUPLE_GET
        const idx = op[1];
        const tup = asTuple(fiber.stack[fiber.sp - 1]);
        if (idx >= tup.length) error("tuple index out of bounds");
        fiber.stack[fiber.sp - 1] = tup[idx];
        break;
      }
      case 50: { // MAKE_RECORD
        const fieldNames = op[1];
        const n = fieldNames.length;
        const values = new Array(n);
        for (let i = n - 1; i >= 0; i--) values[i] = fiber.stack[--fiber.sp];
        const fields = fieldNames.map((name, i) => [name, values[i]]);
        fiber.stack[fiber.sp++] = vrecord(fields);
        break;
      }
      case 51: { // FIELD
        const name = op[1];
        const rec = asRecord(fiber.stack[fiber.sp - 1]);
        const entry = rec.find(([n]) => n === name);
        if (!entry) error(`record has no field: ${name}`);
        fiber.stack[fiber.sp - 1] = entry[1];
        break;
      }
      case 52: { // SET_FIELD
        const name = op[1];
        const newVal = fiber.stack[--fiber.sp];
        const rec = asRecord(fiber.stack[--fiber.sp]);
        let found = false;
        for (let i = 0; i < rec.length; i++) {
          if (rec[i][0] === name) { rec[i] = [name, newVal]; found = true; break; }
        }
        if (!found) error(`record has no field: ${name}`);
        break;
      }
      case 75: { // RECORD_UPDATE
        const fieldNames = op[1];
        const n = fieldNames.length;
        const newVals = new Array(n);
        for (let i = n - 1; i >= 0; i--) newVals[i] = fiber.stack[--fiber.sp];
        const baseRec = asRecord(fiber.stack[--fiber.sp]);
        const copy = baseRec.map(([n, v]) => [n, v]);
        for (let i = 0; i < n; i++) {
          const name = fieldNames[i];
          const idx = copy.findIndex(([n]) => n === name);
          if (idx < 0) error(`record has no field: ${name}`);
          copy[idx] = [name, newVals[i]];
        }
        fiber.stack[fiber.sp++] = vrecord(copy);
        break;
      }
      case 76: { // RECORD_UPDATE_DYN
        const n = op[1];
        const pairs = new Array(n);
        for (let i = n - 1; i >= 0; i--) {
          const v = fiber.stack[--fiber.sp];
          const idx = asInt(fiber.stack[--fiber.sp]);
          pairs[i] = [idx, v];
        }
        const baseRec = asRecord(fiber.stack[--fiber.sp]);
        const copy = baseRec.map(([n, v]) => [n, v]);
        for (const [idx, v] of pairs) {
          if (idx < 0 || idx >= copy.length)
            error(`RECORD_UPDATE_DYN: index ${idx} out of bounds (record has ${copy.length} fields)`);
          copy[idx] = [copy[idx][0], v];
        }
        fiber.stack[fiber.sp++] = vrecord(copy);
        break;
      }
      case 53: { // MAKE_VARIANT
        const [, tagN, name, hasPayload] = op;
        if (hasPayload) {
          fiber.stack[fiber.sp - 1] = vvariant(tagN, name, fiber.stack[fiber.sp - 1]);
        } else {
          fiber.stack[fiber.sp++] = vvariant(tagN, name, null);
        }
        break;
      }
      case 54: { // CONS
        const tl = fiber.stack[--fiber.sp];
        const hd = fiber.stack[--fiber.sp];
        asList(tl); // validate
        fiber.stack[fiber.sp++] = { tag: "list", hd, tl };
        break;
      }
      case 55: // NIL
        fiber.stack[fiber.sp++] = VNIL;
        break;
      case 56: { // TAG_EQ
        const tagN = op[1];
        fiber.stack[fiber.sp - 1] = vbool(asVariant(fiber.stack[fiber.sp - 1]).tagN === tagN);
        break;
      }
      case 57: { // IS_NIL
        const v = asList(fiber.stack[fiber.sp - 1]);
        fiber.stack[fiber.sp - 1] = vbool(!("hd" in v));
        break;
      }
      case 58: { // IS_CONS
        const v = asList(fiber.stack[fiber.sp - 1]);
        fiber.stack[fiber.sp - 1] = vbool("hd" in v);
        break;
      }
      case 59: { // HEAD
        const v = asList(fiber.stack[fiber.sp - 1]);
        if (!("hd" in v)) error("head of empty list");
        fiber.stack[fiber.sp - 1] = v.hd;
        break;
      }
      case 60: { // TAIL
        const v = asList(fiber.stack[fiber.sp - 1]);
        if (!("hd" in v)) error("tail of empty list");
        fiber.stack[fiber.sp - 1] = v.tl;
        break;
      }
      case 61: { // VARIANT_PAYLOAD
        const v = asVariant(fiber.stack[fiber.sp - 1]);
        if (v.payload === null) error("variant has no payload");
        fiber.stack[fiber.sp - 1] = v.payload;
        break;
      }
      case 62: // MATCH_FAIL
        error(`non-exhaustive match at ${op[1]}`);
        break;
      case 63: { // PERFORM
        const opNameStr = op[1];
        const arg = fiber.stack[--fiber.sp];
        // Find matching handler and its index
        let matchIdx = -1;
        let he = null;
        for (let i = vm.handlerStack.length - 1; i >= 0; i--) {
          const h = vm.handlerStack[i];
          for (const [name] of h.ops) {
            if (name === opNameStr) { matchIdx = i; he = h; break; }
          }
          if (he) break;
        }
        if (!he) error(`unhandled effect operation: ${opNameStr}`);
        const handlerFn = he.ops.find(([name]) => name === opNameStr)[1];
        // Collect intermediate handlers (pushed after matched = more inner)
        const intermediates = vm.handlerStack.slice(matchIdx + 1);
        const cont = vcontinuation(fiber, he.returnHandler, he.ops, he.bodyFiber, intermediates);
        const pair = vtuple([arg, cont]);
        // Remove matched handler and all intermediates
        vm.handlerStack = vm.handlerStack.slice(0, matchIdx);
        fiber = he.parentFiber;
        vm.currentFiber = fiber;
        internalCall(fiber, asClosure(handlerFn), pair);
        break;
      }
      case 64: { // HANDLE
        const nOps = op[1];
        const ops = [];
        for (let i = 0; i < nOps; i++) {
          const handlerClosure = fiber.stack[--fiber.sp];
          const opStr = asString(fiber.stack[--fiber.sp]);
          ops.push([opStr, handlerClosure]);
        }
        const returnHandler = fiber.stack[--fiber.sp];
        const bodyThunk = fiber.stack[--fiber.sp];
        const bodyFiber = makeFiber();
        const he = {
          returnHandler,
          ops,
          bodyFiber,
          parentFiber: fiber,
        };
        vm.handlerStack.push(he);
        fiber = bodyFiber;
        vm.currentFiber = fiber;
        internalCall(fiber, asClosure(bodyThunk), VUNIT);
        break;
      }
      case 65: { // RESUME
        const v = fiber.stack[--fiber.sp];
        const cont = asContinuation(fiber.stack[--fiber.sp]);
        if (cont.used) error("continuation already resumed");
        cont.used = true;
        const bodyFiber = cont.fiber;
        bodyFiber.stack[bodyFiber.sp++] = v;
        // Reinstall caught handler with original body fiber
        const he = {
          returnHandler: cont.returnHandler,
          ops: cont.opHandlers,
          bodyFiber: cont.bodyFiber,
          parentFiber: fiber,
        };
        // Reinstall caught handler then intermediates (innermost last = pushed last)
        vm.handlerStack.push(he, ...cont.intermediateHandlers);
        fiber = bodyFiber;
        vm.currentFiber = fiber;
        break;
      }
      case 66: { // ENTER_LOOP
        const breakTarget = op[1];
        vm.controlStack.push({
          breakIp: breakTarget,
          fiber: fiber,
          frameDepth: fiber.frames.length,
          stackDepth: fiber.sp,
        });
        break;
      }
      case 67: { // EXIT_LOOP
        if (vm.controlStack.length === 0) error("EXIT_LOOP: no control entry");
        vm.controlStack.pop();
        break;
      }
      case 68: { // LOOP_BREAK
        const breakValue = fiber.stack[--fiber.sp];
        if (vm.controlStack.length === 0) error("LOOP_BREAK: no control entry");
        const ce = vm.controlStack.pop();
        const cf = ce.fiber;
        while (cf.frames.length > ce.frameDepth) cf.frames.pop();
        cf.sp = ce.stackDepth;
        vm.currentFiber = cf;
        fiber = cf;
        fiber.stack[fiber.sp++] = breakValue;
        fiber.frames[fiber.frames.length - 1].ip = ce.breakIp;
        break;
      }
      case 69: { // LOOP_CONTINUE
        const target = op[1];
        if (vm.controlStack.length === 0) error("LOOP_CONTINUE: no control entry");
        const ce = vm.controlStack[vm.controlStack.length - 1];
        ce.fiber.sp = ce.stackDepth;
        f.ip = target;
        break;
      }
      case 70: { // FOLD_CONTINUE
        const continueValue = fiber.stack[--fiber.sp];
        // Restore sp to frame base (cleans up locals + temps)
        fiber.sp = fiber.frames[fiber.frames.length - 1].baseSp;
        // Pop the fold callback frame and push result
        if (fiber.frames.length <= 1) error("FOLD_CONTINUE: no frame to return from");
        fiber.frames.pop();
        fiber.stack[fiber.sp++] = continueValue;
        break;
      }
      case 46: { // ENTER_FUNC
        vm.returnStack.push({
          fiber: fiber,
          frameDepth: fiber.frames.length,
        });
        break;
      }
      case 47: { // EXIT_FUNC
        if (vm.returnStack.length === 0) error("EXIT_FUNC: no return entry");
        vm.returnStack.pop();
        break;
      }
      case 45: { // FUNC_RETURN
        const result = fiber.stack[--fiber.sp];
        // Find and remove the return entry for this fiber
        let reIdx = -1;
        for (let i = vm.returnStack.length - 1; i >= 0; i--) {
          if (vm.returnStack[i].fiber === fiber) { reIdx = i; break; }
        }
        if (reIdx === -1) error("FUNC_RETURN: no return entry");
        const re = vm.returnStack[reIdx];
        vm.returnStack.splice(reIdx, 1);
        const targetDepth = re.frameDepth;
        // Unwind frames back to the target function
        while (fiber.frames.length > targetDepth) fiber.frames.pop();
        // Clean up control_stack entries above target depth
        vm.controlStack = vm.controlStack.filter(ce =>
          !(ce.fiber === fiber && ce.frameDepth >= targetDepth)
        );
        // Restore stack pointer and pop the target function's frame
        const baseSp = fiber.frames[fiber.frames.length - 1].baseSp;
        fiber.sp = baseSp;
        fiber.frames.pop();
        // Clear any extra_args from over-applications within the unwound frames
        fiber.extraArgs = [];
        if (fiber.frames.length === 0) {
          const he = findHandlerForFiber(vm, fiber);
          if (he) {
            removeHandler(vm, he);
            fiber = he.parentFiber;
            vm.currentFiber = fiber;
            internalCall(fiber, asClosure(he.returnHandler), result);
          } else {
            return result;
          }
        } else {
          fiber.stack[fiber.sp++] = result;
        }
        break;
      }
      case 71: { // MAKE_MAP
        const n = op[1];
        const pairs = [];
        for (let i = 0; i < n; i++) {
          const v = fiber.stack[--fiber.sp];
          const k = fiber.stack[--fiber.sp];
          pairs.unshift([k, v]);
        }
        fiber.stack[fiber.sp++] = vmap(pairs);
        break;
      }
      case 72: { // MAKE_ARRAY
        const n = op[1];
        const elems = [];
        for (let i = 0; i < n; i++) {
          elems.unshift(fiber.stack[--fiber.sp]);
        }
        fiber.stack[fiber.sp++] = varray(elems);
        break;
      }
      case 73: { // INDEX
        const idx = asInt(fiber.stack[--fiber.sp]);
        const base = fiber.stack[--fiber.sp];
        if (base.tag === "string") {
          const s = base.v;
          // Get byte at index (matching OCaml's string byte indexing)
          const encoder = new TextEncoder();
          const bytes = encoder.encode(s);
          if (idx < 0 || idx >= bytes.length)
            error(`string index out of bounds: ${idx} (length ${bytes.length})`);
          fiber.stack[fiber.sp++] = vbyte(bytes[idx]);
        } else if (base.tag === "array") {
          if (idx < 0 || idx >= base.v.length)
            error(`array index out of bounds: ${idx} (length ${base.v.length})`);
          fiber.stack[fiber.sp++] = base.v[idx];
        } else {
          error("index operation requires string or array");
        }
        break;
      }
      case 77: { // GET_LOCAL_CALL
        const fnVal = fiber.stack[--fiber.sp];
        const arg = fiber.stack[f.baseSp + op[1]];
        if (fnVal.tag === "closure") {
          if (fnVal.proto.arity === 1) {
            const base = fiber.sp;
            const numLocals = fnVal.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            fiber.stack[base] = arg;
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: fnVal, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal, [arg]);
          }
        } else if (fnVal.tag === "partial") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.closure.proto.arity) {
            const cls = fnVal.closure;
            const base = fiber.sp;
            const numLocals = cls.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            for (let i = 0; i < newArgs.length; i++) fiber.stack[base + i] = newArgs[i];
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: cls, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal.closure, newArgs);
          }
        } else if (fnVal.tag === "external") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.arity) {
            fiber.stack[fiber.sp++] = fnVal.fn(newArgs);
          } else {
            fiber.stack[fiber.sp++] = vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs);
          }
        } else {
          error(`expected function, got ${ppValue(fnVal)}`);
        }
        break;
      }
      case 78: { // GET_LOCAL_TUPLE_GET
        const tup = asTuple(fiber.stack[f.baseSp + op[1]]);
        const idx = op[2];
        if (idx >= tup.length) error("tuple index out of bounds");
        fiber.stack[fiber.sp++] = tup[idx];
        break;
      }
      case 79: { // GET_LOCAL_FIELD
        const rec = asRecord(fiber.stack[f.baseSp + op[1]]);
        const name = op[2];
        const entry = rec.find(([n]) => n === name);
        if (!entry) error(`record has no field: ${name}`);
        fiber.stack[fiber.sp++] = entry[1];
        break;
      }
      case 80: { // JUMP_TABLE
        const minTag = op[1];
        const targets = op[2];
        const defaultTarget = op[3];
        const v = asVariant(fiber.stack[--fiber.sp]);
        const idx = v.tagN - minTag;
        if (idx >= 0 && idx < targets.length) {
          f.ip = targets[idx];
        } else {
          f.ip = defaultTarget;
        }
        break;
      }
      case 81: { // GET_GLOBAL_CALL
        const fnVal = fiber.stack[--fiber.sp];
        const gidx = op[1];
        const arg = vm.globals.get(gidx);
        if (arg === undefined) {
          const name = gidx < vm.globalNames.length ? vm.globalNames[gidx] : "?";
          error(`undefined global: ${name}`);
        }
        if (fnVal.tag === "closure") {
          if (fnVal.proto.arity === 1) {
            const base = fiber.sp;
            const numLocals = fnVal.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            fiber.stack[base] = arg;
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: fnVal, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal, [arg]);
          }
        } else if (fnVal.tag === "partial") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.closure.proto.arity) {
            const cls = fnVal.closure;
            const base = fiber.sp;
            const numLocals = cls.proto.num_locals;
            fiber.stack.fill(VUNIT, base, base + numLocals);
            for (let i = 0; i < newArgs.length; i++) fiber.stack[base + i] = newArgs[i];
            fiber.sp = base + numLocals;
            fiber.frames.push({ closure: cls, ip: 0, baseSp: base });
          } else {
            fiber.stack[fiber.sp++] = vpartial(fnVal.closure, newArgs);
          }
        } else if (fnVal.tag === "external") {
          const newArgs = fnVal.args.concat([arg]);
          if (newArgs.length === fnVal.arity) {
            fiber.stack[fiber.sp++] = fnVal.fn(newArgs);
          } else {
            fiber.stack[fiber.sp++] = vexternal(fnVal.name, fnVal.arity, fnVal.fn, newArgs);
          }
        } else {
          error(`expected function, got ${ppValue(fnVal)}`);
        }
        break;
      }
      case 82: { // GET_GLOBAL_FIELD
        const gidx = op[1];
        const name = op[2];
        const val = vm.globals.get(gidx);
        if (val === undefined) {
          const gname = gidx < vm.globalNames.length ? vm.globalNames[gidx] : "?";
          error(`undefined global: ${gname}`);
        }
        const rec = asRecord(val);
        const entry = rec.find(([n]) => n === name);
        if (!entry) error(`record has no field: ${name}`);
        fiber.stack[fiber.sp++] = entry[1];
        break;
      }
      case 85: { // UPDATE_REC
        const placeholder = fiber.stack[--fiber.sp];
        const computed = fiber.stack[--fiber.sp];
        if (placeholder.tag === "list" && computed.tag === "list") {
          placeholder.hd = computed.hd;
          placeholder.tl = computed.tl;
        } else if (placeholder.tag === "tuple" && computed.tag === "tuple") {
          for (let i = 0; i < computed.v.length; i++) placeholder.v[i] = computed.v[i];
        } else if (placeholder.tag === "record" && computed.tag === "record") {
          for (let i = 0; i < computed.v.length; i++) placeholder.v[i] = computed.v[i];
        } else if (placeholder.tag === "array" && computed.tag === "array") {
          for (let i = 0; i < computed.v.length; i++) placeholder.v[i] = computed.v[i];
        } else if (placeholder.tag === "variant" && computed.tag === "variant") {
          placeholder.tagN = computed.tagN;
          placeholder.name = computed.name;
          placeholder.payload = computed.payload;
        } else {
          error("UPDATE_REC: type mismatch between placeholder and computed value");
        }
        break;
      }
      case 74: // HALT
        return fiber.sp > 0 ? fiber.stack[fiber.sp - 1] : VUNIT;
      default:
        error(`unknown opcode: ${op[0]}`);
    }
  }
}

function getProto(currentProto, protoIdx) {
  const c = currentProto.constants[protoIdx];
  if (c.tag !== "proto") error(`expected prototype at constant ${protoIdx}`);
  return c.v;
}

function resolveCapture(fiber, frame, cap) {
  if (cap[0] === "local") return fiber.stack[frame.baseSp + cap[1]];
  if (cap[0] === "upvalue") return frame.closure.upvalues[cap[1]];
  error(`unknown capture type: ${cap[0]}`);
}

// --- Execute a prototype in a VM ---
function executeProto(vm, proto) {
  const fiber = makeFiber();
  const closure = vclosure(proto, []);
  const numLocals = proto.num_locals;
  fiber.stack.fill(VUNIT, 0, numLocals);
  fiber.sp = numLocals;
  fiber.frames.push({ closure, ip: 0, baseSp: 0 });
  vm.currentFiber = fiber;
  try {
    return run(vm);
  } catch (e) {
    if (e instanceof RuntimeError) {
      const fiber = vm.currentFiber;
      const f = fiber.frames.length > 0 ? fiber.frames[fiber.frames.length - 1] : null;
      if (f) {
        const ip = Math.max(0, f.ip - 1);
        const lt = f.closure.proto.line_table;
        const line = lt && ip < lt.length ? lt[ip] : 0;
        if (line > 0) throw new RuntimeError(`[line ${line}] ${e.message}`);
      }
    }
    throw e;
  }
}

// --- Create a fresh VM ---
function createVM(globalNames) {
  return {
    currentFiber: makeFiber(),
    handlerStack: [],
    controlStack: [],
    returnStack: [],
    globals: new Map(),
    globalNames,
  };
}

// --- Call a closure with one argument on an existing VM ---
function callClosure(vmInst, closure, arg) {
  const fiber = makeFiber();
  const numLocals = closure.proto.num_locals;
  fiber.stack.fill(VUNIT, 0, numLocals);
  fiber.stack[0] = arg;
  fiber.sp = numLocals;
  fiber.frames.push({ closure, ip: 0, baseSp: 0 });
  vmInst.currentFiber = fiber;
  vmInst.handlerStack = [];
  vmInst.controlStack = [];
  vmInst.returnStack = [];
  return run(vmInst);
}



// ---- builtins.js ----
// JS implementations of native builtins â€” matches interp.ml + std.ml externals


function stringToUtf8Bytes(s) {
  return new TextEncoder().encode(s);
}

function utf8BytesToString(bytes) {
  return new TextDecoder().decode(bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes));
}

// Build builtins map: ext_name -> { arity, fn }
const builtins = {};

function reg(name, arity, fn) {
  builtins[name] = { arity, fn };
}

// --- Core builtins (interp.ml) ---

reg("mod", 2, (args) => {
  const b = asInt(args[1]);
  if (b === 0) error("modulo by zero");
  return vint(asInt(args[0]) % b);
});

reg("print", 1, (args) => {
  const output = ppValue(args[0]);
  if (typeof globalThis._vmOutput === "function") {
    globalThis._vmOutput(output);
  } else {
    console.log(output);
  }
  return VUNIT;
});

reg("failwith", 1, (args) => {
  error(asString(args[0]));
});

reg("^", 2, (args) =>
  vstring(asString(args[0]) + asString(args[1])));

reg("&&", 2, (args) =>
  vbool(asBool(args[0]) && asBool(args[1])));

reg("||", 2, (args) =>
  vbool(asBool(args[0]) || asBool(args[1])));

reg("not", 1, (args) =>
  vbool(!asBool(args[0])));

reg("phys_equal", 2, (args) =>
  vbool(args[0] === args[1]));

reg("float_of_int", 1, (args) =>
  vfloat(asInt(args[0])));

reg("int_of_float", 1, (args) =>
  vint(Math.trunc(asFloat(args[0]))));

reg("string_of_int", 1, (args) =>
  vstring(String(asInt(args[0]))));

reg("string_of_float", 1, (args) => {
  let f = asFloat(args[0]);
  // Match OCaml's %g format
  let s = formatFloat(f);
  return vstring(s);
});

reg("string_of_bool", 1, (args) =>
  vstring(asBool(args[0]) ? "true" : "false"));

// Map pattern matching now uses Map.has/Map.get from stdlib

// Array operations
reg("array_get", 2, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  return arr[idx];
});

reg("array_length", 1, (args) =>
  vint(asArray(args[0]).length));

// Byte primitives
reg("__byte_to_int", 1, (args) =>
  vint(asByte(args[0])));

reg("__byte_of_int", 1, (args) =>
  vbyte(asInt(args[0]) & 0xFF));

reg("__byte_to_string", 1, (args) => {
  const b = asByte(args[0]);
  return vstring(String.fromCharCode(b));
});

// Rune primitives
reg("__rune_to_int", 1, (args) =>
  vint(asRune(args[0])));

reg("__rune_of_int", 1, (args) =>
  vrune(asInt(args[0])));

reg("__rune_to_string", 1, (args) => {
  const cp = asRune(args[0]);
  return vstring(runeToUtf8(cp));
});

// Math primitives
reg("__math_pow", 2, (args) =>
  vfloat(Math.pow(asFloat(args[0]), asFloat(args[1]))));

reg("__math_sqrt", 1, (args) =>
  vfloat(Math.sqrt(asFloat(args[0]))));

reg("__math_floor", 1, (args) =>
  vint(Math.floor(asFloat(args[0]))));

reg("__math_ceil", 1, (args) =>
  vint(Math.ceil(asFloat(args[0]))));

reg("__math_round", 1, (args) =>
  vint(Math.round(asFloat(args[0]))));

reg("__math_sin", 1, (args) =>
  vfloat(Math.sin(asFloat(args[0]))));

reg("__math_cos", 1, (args) =>
  vfloat(Math.cos(asFloat(args[0]))));

reg("__math_abs_float", 1, (args) =>
  vfloat(Math.abs(asFloat(args[0]))));

// --- Format specifier builtins (interp.ml __fmt_*) ---

reg("__fmt_float", 2, (args) => {
  const prec = asInt(args[0]);
  const f = asFloat(args[1]);
  return vstring(f.toFixed(prec));
});

reg("__fmt_hex", 1, (args) =>
  vstring(asInt(args[0]).toString(16)));

reg("__fmt_hex_upper", 1, (args) =>
  vstring(asInt(args[0]).toString(16).toUpperCase()));

reg("__fmt_oct", 1, (args) =>
  vstring(asInt(args[0]).toString(8)));

reg("__fmt_bin", 1, (args) =>
  vstring(asInt(args[0]).toString(2)));

reg("__fmt_zero_pad", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padStart(width, "0"));
});

reg("__fmt_pad_left", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padStart(width, " "));
});

reg("__fmt_pad_right", 2, (args) => {
  const width = asInt(args[0]);
  const s = asString(args[1]);
  return vstring(s.padEnd(width, " "));
});

// Copy (continuation)
reg("copy_continuation", 1, (args) => {
  const cont = asContinuation(args[0]);
  const newFiber = copyFiber(cont.fiber);
  return {
    tag: "continuation",
    fiber: newFiber,
    returnHandler: cont.returnHandler,
    opHandlers: cont.opHandlers,
    bodyFiber: cont.bodyFiber === cont.fiber ? newFiber : cont.bodyFiber,
    intermediateHandlers: cont.intermediateHandlers || [],
    used: false,
  };
});

// Show value (polymorphic)
reg("__show_value", 1, (args) => vstring(ppValue(args[0])));

// --- Typeclass primitive externs (referenced by stdlib/classes.mml) ---

reg("__index_at_array", 2, (args) => {
  const idx = asInt(args[0]);
  const arr = asArray(args[1]);
  if (idx < 0 || idx >= arr.length)
    error(`array index out of bounds: ${idx} (length ${arr.length})`);
  return arr[idx];
});

reg("__index_at_string", 2, (args) => {
  const idx = asInt(args[0]);
  const s = asString(args[1]);
  if (idx < 0 || idx >= s.length)
    error(`string index out of bounds: ${idx} (length ${s.length})`);
  return vbyte(s.charCodeAt(idx));
});

reg("__num_add_int", 2, (args) =>
  vint(asInt(args[0]) + asInt(args[1])));
reg("__num_sub_int", 2, (args) =>
  vint(asInt(args[0]) - asInt(args[1])));
reg("__num_mul_int", 2, (args) =>
  vint(asInt(args[0]) * asInt(args[1])));
reg("__num_div_int", 2, (args) => {
  const b = asInt(args[1]);
  if (b === 0) error("division by zero");
  return vint(Math.trunc(asInt(args[0]) / b));
});
reg("__num_neg_int", 1, (args) =>
  vint(-asInt(args[0])));

reg("__num_add_float", 2, (args) =>
  vfloat(asFloat(args[0]) + asFloat(args[1])));
reg("__num_sub_float", 2, (args) =>
  vfloat(asFloat(args[0]) - asFloat(args[1])));
reg("__num_mul_float", 2, (args) =>
  vfloat(asFloat(args[0]) * asFloat(args[1])));
reg("__num_div_float", 2, (args) =>
  vfloat(asFloat(args[0]) / asFloat(args[1])));
reg("__num_neg_float", 1, (args) =>
  vfloat(-asFloat(args[0])));

reg("__eq_int", 2, (args) =>
  vbool(asInt(args[0]) === asInt(args[1])));
reg("__neq_int", 2, (args) =>
  vbool(asInt(args[0]) !== asInt(args[1])));
reg("__eq_float", 2, (args) =>
  vbool(asFloat(args[0]) === asFloat(args[1])));
reg("__neq_float", 2, (args) =>
  vbool(asFloat(args[0]) !== asFloat(args[1])));
reg("__eq_string", 2, (args) =>
  vbool(asString(args[0]) === asString(args[1])));
reg("__neq_string", 2, (args) =>
  vbool(asString(args[0]) !== asString(args[1])));
reg("__eq_bool", 2, (args) =>
  vbool(asBool(args[0]) === asBool(args[1])));
reg("__neq_bool", 2, (args) =>
  vbool(asBool(args[0]) !== asBool(args[1])));
reg("__eq_byte", 2, (args) =>
  vbool(asByte(args[0]) === asByte(args[1])));
reg("__neq_byte", 2, (args) =>
  vbool(asByte(args[0]) !== asByte(args[1])));
reg("__eq_rune", 2, (args) =>
  vbool(asRune(args[0]) === asRune(args[1])));
reg("__neq_rune", 2, (args) =>
  vbool(asRune(args[0]) !== asRune(args[1])));

reg("__lt_int", 2, (args) =>
  vbool(asInt(args[0]) < asInt(args[1])));
reg("__gt_int", 2, (args) =>
  vbool(asInt(args[0]) > asInt(args[1])));
reg("__le_int", 2, (args) =>
  vbool(asInt(args[0]) <= asInt(args[1])));
reg("__ge_int", 2, (args) =>
  vbool(asInt(args[0]) >= asInt(args[1])));
reg("__lt_float", 2, (args) =>
  vbool(asFloat(args[0]) < asFloat(args[1])));
reg("__gt_float", 2, (args) =>
  vbool(asFloat(args[0]) > asFloat(args[1])));
reg("__le_float", 2, (args) =>
  vbool(asFloat(args[0]) <= asFloat(args[1])));
reg("__ge_float", 2, (args) =>
  vbool(asFloat(args[0]) >= asFloat(args[1])));
reg("__lt_string", 2, (args) =>
  vbool(asString(args[0]) < asString(args[1])));
reg("__gt_string", 2, (args) =>
  vbool(asString(args[0]) > asString(args[1])));
reg("__le_string", 2, (args) =>
  vbool(asString(args[0]) <= asString(args[1])));
reg("__ge_string", 2, (args) =>
  vbool(asString(args[0]) >= asString(args[1])));
reg("__lt_byte", 2, (args) =>
  vbool(asByte(args[0]) < asByte(args[1])));
reg("__gt_byte", 2, (args) =>
  vbool(asByte(args[0]) > asByte(args[1])));
reg("__le_byte", 2, (args) =>
  vbool(asByte(args[0]) <= asByte(args[1])));
reg("__ge_byte", 2, (args) =>
  vbool(asByte(args[0]) >= asByte(args[1])));
reg("__lt_rune", 2, (args) =>
  vbool(asRune(args[0]) < asRune(args[1])));
reg("__gt_rune", 2, (args) =>
  vbool(asRune(args[0]) > asRune(args[1])));
reg("__le_rune", 2, (args) =>
  vbool(asRune(args[0]) <= asRune(args[1])));
reg("__ge_rune", 2, (args) =>
  vbool(asRune(args[0]) >= asRune(args[1])));

reg("__band_int", 2, (args) =>
  vint(asInt(args[0]) & asInt(args[1])));
reg("__bor_int", 2, (args) =>
  vint(asInt(args[0]) | asInt(args[1])));
reg("__bxor_int", 2, (args) =>
  vint(asInt(args[0]) ^ asInt(args[1])));
reg("__bshl_int", 2, (args) =>
  vint(asInt(args[0]) << asInt(args[1])));
reg("__bshr_int", 2, (args) =>
  vint(asInt(args[0]) >>> asInt(args[1])));
reg("__bnot_int", 1, (args) =>
  vint(~asInt(args[0])));

reg("__show_int", 1, (args) =>
  vstring(String(asInt(args[0]))));
reg("__show_float", 1, (args) =>
  vstring(formatFloat(asFloat(args[0]))));
reg("__show_bool", 1, (args) =>
  vstring(asBool(args[0]) ? "true" : "false"));
reg("__show_string", 1, (args) => args[0]);
reg("__show_unit", 1, () => vstring("()"));
reg("__show_byte", 1, (args) =>
  vstring("#" + asByte(args[0]).toString(16).padStart(2, "0")));
reg("__show_rune", 1, (args) =>
  vstring(ppValue(args[0])));

// --- String module (std.ml register_string) ---

reg("String.length", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return vint(bytes.length);
});

reg("String.sub", 3, (args) => {
  const s = asString(args[0]);
  const bytes = stringToUtf8Bytes(s);
  const start = asInt(args[1]);
  const len = asInt(args[2]);
  if (start < 0 || len < 0 || start + len > bytes.length)
    error(`String.sub: index out of bounds`);
  return vstring(utf8BytesToString(bytes.slice(start, start + len)));
});

reg("String.split", 2, (args) => {
  const sep = asString(args[0]);
  const s = asString(args[1]);
  const parts = s.split(sep);
  return vlist(parts.map(vstring));
});

reg("String.trim", 1, (args) =>
  vstring(asString(args[0]).trim()));

reg("String.starts_with", 2, (args) => {
  const prefix = asString(args[0]);
  const s = asString(args[1]);
  return vbool(s.startsWith(prefix));
});

reg("String.contains", 2, (args) => {
  const sub = asString(args[0]);
  const s = asString(args[1]);
  return vbool(s.includes(sub));
});

reg("String.replace", 3, (args) => {
  const old = asString(args[0]);
  const rep = asString(args[1]);
  const s = asString(args[2]);
  return vstring(s.split(old).join(rep));
});

reg("String.to_int", 1, (args) => {
  const s = asString(args[0]);
  const n = parseInt(s, 10);
  if (isNaN(n) || String(n) !== s)
    return vvariant(0, "None", null);
  return vvariant(1, "Some", vint(n));
});

reg("String.to_float", 1, (args) => {
  const s = asString(args[0]);
  const f = parseFloat(s);
  if (isNaN(f))
    return vvariant(0, "None", null);
  return vvariant(1, "Some", vfloat(f));
});

reg("String.uppercase", 1, (args) =>
  vstring(asString(args[0]).toUpperCase()));

reg("String.lowercase", 1, (args) =>
  vstring(asString(args[0]).toLowerCase()));

reg("String.get", 2, (args) => {
  const s = asString(args[0]);
  const idx = asInt(args[1]);
  const bytes = stringToUtf8Bytes(s);
  if (idx < 0 || idx >= bytes.length)
    error(`String.get: index ${idx} out of bounds (length ${bytes.length})`);
  return vbyte(bytes[idx]);
});

reg("String.to_bytes", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return vlist(Array.from(bytes).map(vbyte));
});

reg("String.of_bytes", 1, (args) => {
  const lst = listToArray(args[0]);
  const bytes = new Uint8Array(lst.map(asByte));
  return vstring(utf8BytesToString(bytes));
});

reg("String.to_byte_array", 1, (args) => {
  const bytes = stringToUtf8Bytes(asString(args[0]));
  return varray(Array.from(bytes).map(vbyte));
});

reg("String.of_byte_array", 1, (args) => {
  const arr = asArray(args[0]);
  const bytes = new Uint8Array(arr.map(asByte));
  return vstring(utf8BytesToString(bytes));
});

reg("String.to_runes", 1, (args) => {
  const s = asString(args[0]);
  const runes = [];
  for (const ch of s) {
    runes.push(vrune(ch.codePointAt(0)));
  }
  return vlist(runes);
});

reg("String.of_runes", 1, (args) => {
  const lst = listToArray(args[0]);
  return vstring(lst.map((r) => runeToUtf8(asRune(r))).join(""));
});

reg("String.get_rune", 2, (args) => {
  const s = asString(args[0]);
  const idx = asInt(args[1]);
  const chars = [...s]; // iterate by codepoints
  if (idx < 0 || idx >= chars.length)
    error(`String.get_rune: index ${idx} out of bounds (length ${chars.length})`);
  return vrune(chars[idx].codePointAt(0));
});

reg("String.of_byte", 1, (args) => {
  const b = asByte(args[0]);
  return vstring(String.fromCharCode(b));
});

reg("String.rune_length", 1, (args) => {
  const s = asString(args[0]);
  return vint([...s].length);
});

reg("String.make", 2, (args) => {
  const n = asInt(args[0]);
  const b = asByte(args[1]);
  return vstring(String.fromCharCode(b).repeat(n));
});

reg("String.index_opt", 2, (args) => {
  const s = asString(args[0]);
  const b = asByte(args[1]);
  const bytes = stringToUtf8Bytes(s);
  const idx = bytes.indexOf(b);
  return idx >= 0 ? vvariant(1, "Some", vint(idx)) : vvariant(0, "None", null);
});

reg("String.rindex_opt", 2, (args) => {
  const s = asString(args[0]);
  const b = asByte(args[1]);
  const bytes = stringToUtf8Bytes(s);
  const idx = bytes.lastIndexOf(b);
  return idx >= 0 ? vvariant(1, "Some", vint(idx)) : vvariant(0, "None", null);
});

reg("String.concat", 2, (args) => {
  const sep = asString(args[0]);
  const lst = listToArray(args[1]);
  const strs = lst.map(v => asString(v));
  return vstring(strs.join(sep));
});

reg("String.compare", 2, (args) => {
  const a = asString(args[0]);
  const b = asString(args[1]);
  return vint(a < b ? -1 : a > b ? 1 : 0);
});

// --- Array module (std.ml register_array) ---

reg("Array.make", 2, (args) => {
  const n = asInt(args[0]);
  const v = args[1];
  return varray(new Array(n).fill(v));
});

reg("Array.get", 2, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  return arr[idx];
});

reg("Array.set", 3, (args) => {
  const arr = asArray(args[0]);
  const idx = asInt(args[1]);
  const v = args[2];
  if (idx < 0 || idx >= arr.length)
    error(`array index ${idx} out of bounds (length ${arr.length})`);
  arr[idx] = v;
  return VUNIT;
});

reg("Array.length", 1, (args) =>
  vint(asArray(args[0]).length));

reg("Array.to_list", 1, (args) =>
  vlist(Array.from(asArray(args[0]))));

reg("Array.of_list", 1, (args) =>
  varray(listToArray(args[0])));

reg("Array.copy", 1, (args) =>
  varray(asArray(args[0]).slice()));

reg("Array.sub", 3, (args) => {
  const arr = asArray(args[0]);
  const start = asInt(args[1]);
  const len = asInt(args[2]);
  return varray(arr.slice(start, start + len));
});

// --- Canvas builtins (browser only, safe to register in Node) ---

reg("Canvas.init", 2, (args) => {
  const w = asInt(args[0]);
  const h = asInt(args[1]);
  if (typeof globalThis._canvasInit === "function") {
    globalThis._canvasInit(w, h);
  }
  return VUNIT;
});

reg("Canvas.clear", 1, (args) => {
  const color = asString(args[0]);
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  }
  return VUNIT;
});

reg("Canvas.fill_rect", 5, (args) => {
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.fillStyle = asString(args[4]);
    ctx.fillRect(asFloat(args[0]), asFloat(args[1]),
                 asFloat(args[2]), asFloat(args[3]));
  }
  return VUNIT;
});

reg("Canvas.stroke_rect", 5, (args) => {
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.strokeStyle = asString(args[4]);
    ctx.lineWidth = 1;
    ctx.strokeRect(asFloat(args[0]), asFloat(args[1]),
                   asFloat(args[2]), asFloat(args[3]));
  }
  return VUNIT;
});

reg("Canvas.fill_circle", 4, (args) => {
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.fillStyle = asString(args[3]);
    ctx.beginPath();
    ctx.arc(asFloat(args[0]), asFloat(args[1]),
            asFloat(args[2]), 0, 2 * Math.PI);
    ctx.fill();
  }
  return VUNIT;
});

reg("Canvas.draw_text", 4, (args) => {
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.fillStyle = asString(args[3]);
    ctx.textBaseline = "top";
    ctx.fillText(asString(args[0]), asFloat(args[1]), asFloat(args[2]));
  }
  return VUNIT;
});

reg("Canvas.set_font", 1, (args) => {
  const ctx = globalThis._canvasCtx;
  if (ctx) {
    ctx.font = asString(args[0]);
  }
  return VUNIT;
});

reg("Canvas.mouse_x", 1, (_args) =>
  vfloat(globalThis._canvasMouseX || 0));

reg("Canvas.mouse_y", 1, (_args) =>
  vfloat(globalThis._canvasMouseY || 0));

reg("Canvas.mouse_down", 1, (_args) =>
  vbool(!!globalThis._canvasMouseDown));

reg("Canvas.mouse_clicked", 1, (_args) =>
  vbool(!!globalThis._canvasMouseClicked));

reg("Canvas.key_down", 1, (args) =>
  vbool(!!globalThis._canvasKeysDown[asString(args[0])]));

reg("Canvas.key_pressed", 1, (args) =>
  vbool(!!globalThis._canvasKeysPressed[asString(args[0])]));

reg("Canvas.start_app", 2, (args) => {
  globalThis._canvasApp = {
    initFn: asClosure(args[0]),
    frameFn: asClosure(args[1]),
  };
  return VUNIT;
});

// --- IO module (browser stubs, configurable via globalThis) ---

reg("IO.read_file", 1, (args) => {
  if (typeof globalThis._vmReadFile === "function") {
    return vstring(globalThis._vmReadFile(asString(args[0])));
  }
  error("IO.read_file not supported in browser");
});
reg("IO.write_file", 2, () => { error("IO.write_file not supported in browser"); });
reg("IO.append_file", 2, () => { error("IO.append_file not supported in browser"); });
reg("IO.read_line", 1, () => { error("IO.read_line not supported in browser"); });
reg("IO.file_exists", 1, () => vbool(false));

// --- Sys module (browser stubs, configurable via globalThis) ---

reg("Sys.args", 1, () => {
  if (globalThis._vmArgs) {
    return vlist(globalThis._vmArgs.map(vstring));
  }
  return vlist([]);
});
reg("Sys.getenv", 1, () => vvariant(0, "None", null));
reg("Sys.exit", 1, () => { error("Sys.exit not supported in browser"); });
reg("Sys.time", 1, () => vfloat(performance.now() / 1000));

// --- Runtime.eval/eval_file (stubs for JS) ---

reg("Runtime.eval", 1, () => {
  error("Runtime.eval not supported in JS VM");
});

reg("Runtime.eval_file", 1, () => {
  error("Runtime.eval_file not supported in JS VM");
});

// --- Helper: OCaml %g-like float formatting ---
function formatFloat(f) {
  if (!isFinite(f)) {
    if (f !== f) return "nan";
    return f > 0 ? "inf" : "-inf";
  }
  // %g uses shortest of %e and %f with 6 significant digits, trims trailing zeros
  let s = f.toPrecision(6);
  // Remove trailing zeros after decimal point
  if (s.includes('.')) {
    s = s.replace(/0+$/, '');
    s = s.replace(/\.$/, '');
  }
  // Handle exponential notation
  if (s.includes('e+')) s = s.replace('e+0', 'e+').replace('e+', 'e+');
  if (s.includes('e-')) s = s.replace('e-0', 'e-');
  // Match OCaml's %g: -0 -> -0
  if (Object.is(f, -0)) return "-0";
  return s;
}



// ---- loader.js ----
// Loader: deserializes JSON bundle and runs it



function deserializeValue(j) {
  switch (j.t) {
    case "i": return vint(j.v);
    case "f": return vfloat(j.v);
    case "b": return vbool(j.v);
    case "s": return vstring(j.v);
    case "y": return vbyte(j.v);
    case "r": return vrune(j.v);
    case "u": return VUNIT;
    case "p": return vproto(deserializePrototype(j.v));
    case "T": return vtuple(j.v.map(deserializeValue));
    case "L": return vlist(j.v.map(deserializeValue));
    case "V": {
      const payload = j.payload === null ? null : deserializeValue(j.payload);
      return vvariant(j.tag, j.name, payload);
    }
    default:
      error(`unknown value type: ${j.t}`);
  }
}

const OPCODE_NAMES = [
  "CONST", "POP", "DUP", "GET_LOCAL", "SET_LOCAL", "GET_UPVALUE", "SET_UPVALUE",
  "MAKE_REF", "DEREF", "SET_REF", "GET_GLOBAL", "SET_GLOBAL", "DEF_GLOBAL",
  "ADD", "SUB", "MUL", "DIV", "MOD", "NEG",
  "FADD", "FSUB", "FMUL", "FDIV", "FNEG",
  "EQ", "NEQ", "LT", "GT", "LE", "GE", "NOT",
  "BAND", "BOR", "BXOR", "BNOT", "BSHL", "BSHR",
  "JUMP", "JUMP_IF_FALSE", "JUMP_IF_TRUE",
  "CLOSURE", "CLOSURE_REC",
  "CALL", "TAIL_CALL", "RETURN", "FUNC_RETURN", "ENTER_FUNC", "EXIT_FUNC",
  "MAKE_TUPLE", "TUPLE_GET",
  "MAKE_RECORD", "FIELD", "SET_FIELD", "MAKE_VARIANT",
  "CONS", "NIL", "TAG_EQ", "IS_NIL", "IS_CONS", "HEAD", "TAIL",
  "VARIANT_PAYLOAD", "MATCH_FAIL",
  "PERFORM", "HANDLE", "RESUME",
  "ENTER_LOOP", "EXIT_LOOP", "LOOP_BREAK", "LOOP_CONTINUE", "FOLD_CONTINUE",
  "MAKE_MAP", "MAKE_ARRAY", "INDEX", "HALT",
  "RECORD_UPDATE", "RECORD_UPDATE_DYN",
  "GET_LOCAL_CALL", "GET_LOCAL_TUPLE_GET", "GET_LOCAL_FIELD", "JUMP_TABLE",
  "GET_GLOBAL_CALL", "GET_GLOBAL_FIELD",
  "CALL_N", "TAIL_CALL_N",
  "UPDATE_REC",
];

// Map string opcode names to numeric tags for the VM switch
const OPCODE_TO_NUM = {};
OPCODE_NAMES.forEach((name, idx) => OPCODE_TO_NUM[name] = idx);

function convertCode(code) {
  for (let i = 0; i < code.length; i++) {
    code[i][0] = OPCODE_TO_NUM[code[i][0]];
  }
  return code;
}

function deserializePrototype(j) {
  return {
    name: j.name,
    arity: j.arity,
    num_locals: j.num_locals,
    code: convertCode(j.code),
    constants: j.constants.map(deserializeValue),
    line_table: j.line_table || [],
  };
}

function makeExternal(name, arity, fn) {
  return vexternal(name, arity, (args) => fn(args));
}

function registerBuiltins(vmInst, bundle) {
  const nativeGlobals = bundle.native_globals;
  for (const [idxStr, info] of Object.entries(nativeGlobals)) {
    const idx = parseInt(idxStr, 10);
    if (info.type === "external") {
      const b = builtins[info.name];
      if (!b) {
        // Skip unknown builtins (e.g. Runtime.eval)
        // Register a stub that errors
        vmInst.globals.set(idx, makeExternal(info.name, info.arity, () => {
          error(`unimplemented builtin: ${info.name}`);
        }));
        continue;
      }
      vmInst.globals.set(idx, makeExternal(info.name, b.arity, b.fn));
    } else if (info.type === "dict") {
      // Typeclass dictionary: record of externals
      const fields = Object.entries(info.fields).map(([fieldName, fieldInfo]) => {
        const b = builtins[fieldInfo.name];
        if (!b) {
          return [fieldName, makeExternal(fieldInfo.name, fieldInfo.arity, () => {
            error(`unimplemented builtin: ${fieldInfo.name}`);
          })];
        }
        return [fieldName, makeExternal(fieldInfo.name, b.arity, b.fn)];
      });
      vmInst.globals.set(idx, vrecord(fields));
    }
  }
}

function loadBundle(jsonString) {
  const bundle = JSON.parse(jsonString);
  const globalNames = bundle.global_names;
  const vmInst = createVM(globalNames);

  // Register native builtins
  registerBuiltins(vmInst, bundle);

  // Register any user-declared externs that match builtins but aren't in native_globals
  for (let i = 0; i < globalNames.length; i++) {
    if (!vmInst.globals.has(i) && builtins[globalNames[i]]) {
      const b = builtins[globalNames[i]];
      vmInst.globals.set(i, makeExternal(globalNames[i], b.arity, b.fn));
    }
  }

  // Run setup prototypes (rebuild source-compiled stdlib)
  for (const setupJson of bundle.setup) {
    const proto = deserializePrototype(setupJson);
    executeProto(vmInst, proto);
  }

  // Store vmInst so canvas apps can call closures after loadBundle returns
  globalThis._vmInstance = vmInst;

  // Run main prototype
  const mainProto = deserializePrototype(bundle.main);
  return executeProto(vmInst, mainProto);
}

// --- Binary MMLB deserializer ---

// Tags for opcodes that take a single u32 operand
const U32_OPCODES = new Set([
  0,  // CONST
  3,  // GET_LOCAL
  4,  // SET_LOCAL
  5,  // GET_UPVALUE
  6,  // SET_UPVALUE
  10, // GET_GLOBAL
  11, // SET_GLOBAL
  12, // DEF_GLOBAL
  37, // JUMP
  38, // JUMP_IF_FALSE
  39, // JUMP_IF_TRUE
  42, // CALL
  43, // TAIL_CALL
  48, // MAKE_TUPLE
  49, // TUPLE_GET
  56, // TAG_EQ
  64, // HANDLE
  66, // ENTER_LOOP
  69, // LOOP_CONTINUE
  70, // FOLD_CONTINUE
  71, // MAKE_MAP
  72, // MAKE_ARRAY
  76, // RECORD_UPDATE_DYN
  83, // CALL_N
  84, // TAIL_CALL_N
]);

function loadBundleBinary(arrayBuffer) {
  const dv = new DataView(arrayBuffer);
  let pos = 0;

  function readU8() { const v = dv.getUint8(pos); pos += 1; return v; }
  function readU32() { const v = dv.getUint32(pos, true); pos += 4; return v; }
  function readI64() { const v = dv.getBigInt64(pos, true); pos += 8; return Number(v); }
  function readF64() { const v = dv.getFloat64(pos, true); pos += 8; return v; }

  // Header
  const magic = String.fromCharCode(readU8(), readU8(), readU8(), readU8());
  if (magic !== "MMLB") throw new Error(`invalid binary bundle magic: ${magic}`);
  const version = readU32();
  if (version !== 1) throw new Error(`unsupported binary bundle version: ${version}`);

  // String table
  const strCount = readU32();
  const strs = new Array(strCount);
  const decoder = new TextDecoder("utf-8");
  for (let i = 0; i < strCount; i++) {
    const len = readU32();
    strs[i] = decoder.decode(new Uint8Array(arrayBuffer, pos, len));
    pos += len;
  }

  // Global names
  const numNames = readU32();
  const globalNames = new Array(numNames);
  for (let i = 0; i < numNames; i++) {
    globalNames[i] = strs[readU32()];
  }

  // Create VM
  const vmInst = createVM(globalNames);

  // Native globals
  const numNatives = readU32();
  for (let i = 0; i < numNatives; i++) {
    const idx = readU32();
    const kind = readU8();
    if (kind === 0) {
      // external
      const name = strs[readU32()];
      const arity = readU32();
      const b = builtins[name];
      if (b) {
        vmInst.globals.set(idx, makeExternal(name, b.arity, b.fn));
      } else {
        vmInst.globals.set(idx, makeExternal(name, arity, () => {
          error(`unimplemented builtin: ${name}`);
        }));
      }
    } else if (kind === 1) {
      // dict
      const numFields = readU32();
      const fields = [];
      for (let j = 0; j < numFields; j++) {
        const fieldName = strs[readU32()];
        const extName = strs[readU32()];
        const extArity = readU32();
        const b = builtins[extName];
        if (b) {
          fields.push([fieldName, makeExternal(extName, b.arity, b.fn)]);
        } else {
          fields.push([fieldName, makeExternal(extName, extArity, () => {
            error(`unimplemented builtin: ${extName}`);
          })]);
        }
      }
      vmInst.globals.set(idx, vrecord(fields));
    }
  }

  // Register any user-declared externs that match builtins but aren't in native_globals
  for (let i = 0; i < globalNames.length; i++) {
    if (!vmInst.globals.has(i) && builtins[globalNames[i]]) {
      const b = builtins[globalNames[i]];
      vmInst.globals.set(i, makeExternal(globalNames[i], b.arity, b.fn));
    }
  }

  function readCaptures() {
    const count = readU32();
    const caps = new Array(count);
    for (let i = 0; i < count; i++) {
      const kind = readU8();
      const idx = readU32();
      caps[i] = kind === 0 ? ["local", idx] : ["upvalue", idx];
    }
    return caps;
  }

  function readOpcode() {
    const tag = readU8();

    // Simple u32 operand opcodes
    if (U32_OPCODES.has(tag)) {
      return [tag, readU32()];
    }

    switch (tag) {
      // No-operand opcodes
      case 1: case 2: case 7: case 8: case 9:
      case 13: case 14: case 15: case 16: case 17: case 18:
      case 19: case 20: case 21: case 22: case 23:
      case 24: case 25: case 26: case 27: case 28: case 29: case 30:
      case 31: case 32: case 33: case 34: case 35: case 36:
      case 44: case 45: case 46: case 47:
      case 54: case 55: case 57: case 58: case 59: case 60:
      case 61: case 65: case 67: case 68: case 73: case 74:
        return [tag];

      case 40: { // CLOSURE
        const protoIdx = readU32();
        const caps = readCaptures();
        return [40, protoIdx, caps];
      }
      case 41: { // CLOSURE_REC
        const protoIdx = readU32();
        const caps = readCaptures();
        const self = readU32();
        return [41, protoIdx, caps, self];
      }
      case 50: { // MAKE_RECORD
        const count = readU32();
        const fieldNames = new Array(count);
        for (let i = 0; i < count; i++) fieldNames[i] = strs[readU32()];
        return [50, fieldNames];
      }
      case 51: // FIELD
        return [51, strs[readU32()]];
      case 52: // SET_FIELD
        return [52, strs[readU32()]];
      case 53: { // MAKE_VARIANT
        const tagN = readU32();
        const vname = strs[readU32()];
        const hasPayload = readU8() !== 0;
        return [53, tagN, vname, hasPayload];
      }
      case 62: // MATCH_FAIL
        return [62, strs[readU32()]];
      case 63: // PERFORM
        return [63, strs[readU32()]];
      case 75: { // RECORD_UPDATE
        const count = readU32();
        const fieldNames = new Array(count);
        for (let i = 0; i < count; i++) fieldNames[i] = strs[readU32()];
        return [75, fieldNames];
      }
      case 77: { // GET_LOCAL_CALL
        const slot = readU32();
        const arity = readU32();
        return [77, slot, arity];
      }
      case 78: { // GET_LOCAL_TUPLE_GET
        const slot = readU32();
        const idx = readU32();
        return [78, slot, idx];
      }
      case 79: { // GET_LOCAL_FIELD
        const slot = readU32();
        const name = strs[readU32()];
        return [79, slot, name];
      }
      case 80: { // JUMP_TABLE
        const minTag = readU32();
        const tableSize = readU32();
        const targets = new Array(tableSize);
        for (let i = 0; i < tableSize; i++) targets[i] = readU32();
        const defaultTarget = readU32();
        return [80, minTag, targets, defaultTarget];
      }
      case 81: { // GET_GLOBAL_CALL
        const idx = readU32();
        const arity = readU32();
        return [81, idx, arity];
      }
      case 82: { // GET_GLOBAL_FIELD
        const idx = readU32();
        const name = strs[readU32()];
        return [82, idx, name];
      }
      default:
        throw new Error(`unknown opcode tag: ${tag}`);
    }
  }

  function readValue() {
    const tag = readU8();
    switch (tag) {
      case 0: return vint(readI64());
      case 1: return vfloat(readF64());
      case 2: return vbool(readU8() !== 0);
      case 3: return vstring(strs[readU32()]);
      case 4: return vbyte(readU8());
      case 5: return vrune(readU32());
      case 6: return VUNIT;
      case 7: return vproto(readPrototype());
      case 8: {
        const count = readU32();
        const vs = new Array(count);
        for (let i = 0; i < count; i++) vs[i] = readValue();
        return vtuple(vs);
      }
      case 9: {
        const count = readU32();
        const vs = new Array(count);
        for (let i = 0; i < count; i++) vs[i] = readValue();
        return vlist(vs);
      }
      case 10: {
        const tagN = readU32();
        const vname = strs[readU32()];
        const hasPayload = readU8() !== 0;
        const payload = hasPayload ? readValue() : null;
        return vvariant(tagN, vname, payload);
      }
      default:
        throw new Error(`unknown value tag: ${tag}`);
    }
  }

  function readPrototype() {
    const name = strs[readU32()];
    const arity = readU32();
    const numLocals = readU32();
    const codeLen = readU32();
    const code = new Array(codeLen);
    for (let i = 0; i < codeLen; i++) code[i] = readOpcode();
    const constLen = readU32();
    const constants = new Array(constLen);
    for (let i = 0; i < constLen; i++) constants[i] = readValue();
    const linesLen = readU32();
    const lineTable = new Array(linesLen);
    for (let i = 0; i < linesLen; i++) lineTable[i] = readU32();
    return { name, arity, num_locals: numLocals, code, constants, line_table: lineTable };
  }

  // Setup protos
  const numSetup = readU32();
  for (let i = 0; i < numSetup; i++) {
    const proto = readPrototype();
    executeProto(vmInst, proto);
  }

  // Store vmInst so canvas apps can call closures after loadBundle returns
  globalThis._vmInstance = vmInst;

  // Main proto
  const mainProto = readPrototype();
  return executeProto(vmInst, mainProto);
}



// ---- Stdlib sources (embedded for self-hosted compiler) ----
const STDLIB_SOURCES = {"stdlib/classes.mml":"(* ---- Typeclass primitive externs ---- *)\n(* These are provided by each backend (OCaml VM, JS, native) *)\n\n(* Num primitives *)\nextern __num_add_int : int -> int -> int\nextern __num_sub_int : int -> int -> int\nextern __num_mul_int : int -> int -> int\nextern __num_div_int : int -> int -> int\nextern __num_neg_int : int -> int\nextern __num_add_float : float -> float -> float\nextern __num_sub_float : float -> float -> float\nextern __num_mul_float : float -> float -> float\nextern __num_div_float : float -> float -> float\nextern __num_neg_float : float -> float\n\n(* Eq primitives *)\nextern __eq_int : int -> int -> bool\nextern __neq_int : int -> int -> bool\nextern __eq_float : float -> float -> bool\nextern __neq_float : float -> float -> bool\nextern __eq_string : string -> string -> bool\nextern __neq_string : string -> string -> bool\nextern __eq_bool : bool -> bool -> bool\nextern __neq_bool : bool -> bool -> bool\nextern __eq_byte : byte -> byte -> bool\nextern __neq_byte : byte -> byte -> bool\nextern __eq_rune : rune -> rune -> bool\nextern __neq_rune : rune -> rune -> bool\n\n(* Ord primitives *)\nextern __lt_int : int -> int -> bool\nextern __gt_int : int -> int -> bool\nextern __le_int : int -> int -> bool\nextern __ge_int : int -> int -> bool\nextern __lt_float : float -> float -> bool\nextern __gt_float : float -> float -> bool\nextern __le_float : float -> float -> bool\nextern __ge_float : float -> float -> bool\nextern __lt_string : string -> string -> bool\nextern __gt_string : string -> string -> bool\nextern __le_string : string -> string -> bool\nextern __ge_string : string -> string -> bool\nextern __lt_byte : byte -> byte -> bool\nextern __gt_byte : byte -> byte -> bool\nextern __le_byte : byte -> byte -> bool\nextern __ge_byte : byte -> byte -> bool\nextern __lt_rune : rune -> rune -> bool\nextern __gt_rune : rune -> rune -> bool\nextern __le_rune : rune -> rune -> bool\nextern __ge_rune : rune -> rune -> bool\n\n(* Bitwise primitives *)\nextern __band_int : int -> int -> int\nextern __bor_int : int -> int -> int\nextern __bxor_int : int -> int -> int\nextern __bshl_int : int -> int -> int\nextern __bshr_int : int -> int -> int\nextern __bnot_int : int -> int\n\n(* Show primitives *)\nextern __show_int : int -> string\nextern __show_float : float -> string\nextern __show_bool : bool -> string\nextern __show_string : string -> string\nextern __show_unit : unit -> string\nextern __show_byte : byte -> string\nextern __show_rune : rune -> string\n\n(* Index primitives *)\nextern __index_at_array : int -> 'a array -> 'a\nextern __index_at_string : int -> string -> byte\n\n;;\n\n(* ---- Class definitions ---- *)\n\nclass Num 'a =\n  (+) : 'a -> 'a -> 'a\n  (-) : 'a -> 'a -> 'a\n  (*) : 'a -> 'a -> 'a\n  (/) : 'a -> 'a -> 'a\n  neg : 'a -> 'a\nend\n;;\nclass Eq 'a =\n  (=) : 'a -> 'a -> bool\n  (<>) : 'a -> 'a -> bool\nend\n;;\nclass Ord 'a =\n  (<) : 'a -> 'a -> bool\n  (>) : 'a -> 'a -> bool\n  (<=) : 'a -> 'a -> bool\n  (>=) : 'a -> 'a -> bool\nend\n;;\nclass Bitwise 'a =\n  (land) : 'a -> 'a -> 'a\n  (lor) : 'a -> 'a -> 'a\n  (lxor) : 'a -> 'a -> 'a\n  (lsl) : 'a -> 'a -> 'a\n  (lsr) : 'a -> 'a -> 'a\n  (lnot) : 'a -> 'a\nend\n;;\nclass Show 'a =\n  show : 'a -> string\nend\n;;\nclass Iter 'a 'b where 'a -> 'b =\n  fold : ('c -> 'b -> 'c) -> 'c -> 'a -> 'c\nend\n;;\nclass Index 'c 'k 'v where 'c -> 'k 'v =\n  at : 'k -> 'c -> 'v\nend\n\n;;\n\n(* ---- Primitive instances ---- *)\n\ninstance Num int =\n  let (+) = __num_add_int\n  let (-) = __num_sub_int\n  let (*) = __num_mul_int\n  let (/) = __num_div_int\n  let neg = __num_neg_int\nend\n;;\ninstance Num float =\n  let (+) = __num_add_float\n  let (-) = __num_sub_float\n  let (*) = __num_mul_float\n  let (/) = __num_div_float\n  let neg = __num_neg_float\nend\n\n;;\n\ninstance Eq int =\n  let (=) = __eq_int\n  let (<>) = __neq_int\nend\n;;\ninstance Eq float =\n  let (=) = __eq_float\n  let (<>) = __neq_float\nend\n;;\ninstance Eq string =\n  let (=) = __eq_string\n  let (<>) = __neq_string\nend\n;;\ninstance Eq bool =\n  let (=) = __eq_bool\n  let (<>) = __neq_bool\nend\n;;\ninstance Eq byte =\n  let (=) = __eq_byte\n  let (<>) = __neq_byte\nend\n;;\ninstance Eq rune =\n  let (=) = __eq_rune\n  let (<>) = __neq_rune\nend\n\n;;\n\ninstance Ord int =\n  let (<) = __lt_int\n  let (>) = __gt_int\n  let (<=) = __le_int\n  let (>=) = __ge_int\nend\n;;\ninstance Ord float =\n  let (<) = __lt_float\n  let (>) = __gt_float\n  let (<=) = __le_float\n  let (>=) = __ge_float\nend\n;;\ninstance Ord string =\n  let (<) = __lt_string\n  let (>) = __gt_string\n  let (<=) = __le_string\n  let (>=) = __ge_string\nend\n;;\ninstance Ord byte =\n  let (<) = __lt_byte\n  let (>) = __gt_byte\n  let (<=) = __le_byte\n  let (>=) = __ge_byte\nend\n;;\ninstance Ord rune =\n  let (<) = __lt_rune\n  let (>) = __gt_rune\n  let (<=) = __le_rune\n  let (>=) = __ge_rune\nend\n\n;;\n\ninstance Bitwise int =\n  let (land) = __band_int\n  let (lor) = __bor_int\n  let (lxor) = __bxor_int\n  let (lsl) = __bshl_int\n  let (lsr) = __bshr_int\n  let (lnot) = __bnot_int\nend\n\n;;\n\ninstance Show int =\n  let show = __show_int\nend\n;;\ninstance Show float =\n  let show = __show_float\nend\n;;\ninstance Show bool =\n  let show = __show_bool\nend\n;;\ninstance Show string =\n  let show = __show_string\nend\n;;\ninstance Show unit =\n  let show = __show_unit\nend\n;;\ninstance Show byte =\n  let show = __show_byte\nend\n;;\ninstance Show rune =\n  let show = __show_rune\nend\n\n;;\n\ninstance Index ('a array) int 'a =\n  let at = __index_at_array\nend\n;;\ninstance Index string int byte =\n  let at = __index_at_string\nend\n","stdlib/option_type.mml":"type 'a option = None | Some of 'a\n","stdlib/iter.mml":"instance Iter ('a list) 'a =\n  let fold f acc xs =\n    let rec go a l = match l with\n      | [] -> a\n      | x :: rest -> go (f a x) rest\n    in go acc xs\nend\n\ninstance Iter ('a array) 'a =\n  let fold = fn f -> fn acc -> fn arr ->\n    let rec go = fn a -> fn i ->\n      if i = array_length arr do a\n      else go (f a (array_get arr i)) (i + 1)\n    in go acc 0\nend\n","stdlib/map_class.mml":"class Map 'm 'k 'v where 'm -> 'k 'v =\n  of_list : ('k * 'v) list -> 'm\n  get     : 'k -> 'm -> 'v option\n  set     : 'k -> 'v -> 'm -> 'm\n  has     : 'k -> 'm -> bool\n  remove  : 'k -> 'm -> 'm\n  size    : 'm -> int\n  keys    : 'm -> 'k list\n  values  : 'm -> 'v list\n  to_list : 'm -> ('k * 'v) list\nend\n","stdlib/show.mml":"instance Show ('a list) where Show 'a =\n  let show xs = match xs with\n    | [] -> \"[]\"\n    | _ -> \"[\" ^ fold (fn acc x ->\n        if acc = \"\" do show x else acc ^ \"; \" ^ show x\n      ) \"\" xs ^ \"]\"\nend\n\ninstance Show ('a array) where Show 'a =\n  let show arr =\n    if array_length arr = 0 do \"#[]\"\n    else \"#[\" ^ fold (fn acc x ->\n      if acc = \"\" do show x else acc ^ \"; \" ^ show x\n    ) \"\" arr ^ \"]\"\nend\n\ninstance Show ('a option) where Show 'a =\n  let show opt = match opt with\n    | None -> \"None\"\n    | Some x -> \"Some \" ^ show x\nend\n\ninstance Show ('a * 'b) where Show 'a, Show 'b =\n  let show p =\n    let (a, b) = p in\n    \"(\" ^ show a ^ \", \" ^ show b ^ \")\"\nend\n\ninstance Show ('a * 'b * 'c) where Show 'a, Show 'b, Show 'c =\n  let show p =\n    let (a, b, c) = p in\n    \"(\" ^ show a ^ \", \" ^ show b ^ \", \" ^ show c ^ \")\"\nend\n","stdlib/byte.mml":"module Byte =\n  pub let to_int (b : byte) : int = __byte_to_int b\n  pub let of_int (n : int) : byte = __byte_of_int n\n  pub let to_string (b : byte) : string = __byte_to_string b\n  pub let is_alpha (b : byte) : bool =\n    let n = Byte.to_int b in\n    (n >= 65 && n <= 90) || (n >= 97 && n <= 122)\n  pub let is_digit (b : byte) : bool =\n    let n = Byte.to_int b in\n    n >= 48 && n <= 57\n  pub let is_space (b : byte) : bool =\n    let n = Byte.to_int b in\n    n = 32 || n = 9 || n = 10 || n = 13\n  pub let is_upper (b : byte) : bool =\n    let n = Byte.to_int b in\n    n >= 65 && n <= 90\n  pub let is_lower (b : byte) : bool =\n    let n = Byte.to_int b in\n    n >= 97 && n <= 122\n  pub let to_upper (b : byte) : byte =\n    let n = Byte.to_int b in\n    if n >= 97 && n <= 122 do Byte.of_int (n - 32) else b\n  pub let to_lower (b : byte) : byte =\n    let n = Byte.to_int b in\n    if n >= 65 && n <= 90 do Byte.of_int (n + 32) else b\nend\n","stdlib/rune.mml":"module Rune =\n  pub let to_int (r : rune) : int = __rune_to_int r\n  pub let of_int (n : int) : rune = __rune_of_int n\n  pub let to_string (r : rune) : string = __rune_to_string r\n  pub let is_alpha (r : rune) : bool =\n    let n = Rune.to_int r in\n    (n >= 65 && n <= 90) || (n >= 97 && n <= 122)\n  pub let is_digit (r : rune) : bool =\n    let n = Rune.to_int r in\n    n >= 48 && n <= 57\n  pub let is_space (r : rune) : bool =\n    let n = Rune.to_int r in\n    n = 32 || n = 9 || n = 10 || n = 13\n  pub let is_upper (r : rune) : bool =\n    let n = Rune.to_int r in\n    n >= 65 && n <= 90\n  pub let is_lower (r : rune) : bool =\n    let n = Rune.to_int r in\n    n >= 97 && n <= 122\nend\n","stdlib/math.mml":"module Math =\n  pub let abs (x : int) : int = if x < 0 do 0 - x else x\n  pub let min (a : int) (b : int) : int = if a < b do a else b\n  pub let max (a : int) (b : int) : int = if a > b do a else b\n  pub let pow (a : float) (b : float) : float = __math_pow a b\n  pub let sqrt (x : float) : float = __math_sqrt x\n  pub let floor (x : float) : int = __math_floor x\n  pub let ceil (x : float) : int = __math_ceil x\n  pub let round (x : float) : int = __math_round x\nend\n","stdlib/list.mml":"module List =\n  pub let fold (f: 'b -> 'a -> 'b) (acc: 'b) (xs: 'a list) : 'b =\n    let rec go a l =\n      match l with\n      | [] -> a\n      | x :: rest -> go (f a x) rest\n    in go acc xs\n\n  pub let length xs = List.fold (fn acc _ -> acc + 1) 0 xs\n\n  pub let rev xs = List.fold (fn acc x -> x :: acc) [] xs\n\n  pub let hd xs =\n    @partial\n    match xs with\n    | x :: _ -> x\n\n  pub let tl xs =\n    @partial\n    match xs with\n    | _ :: rest -> rest\n\n  pub let nth xs n =\n    let rec go l i =\n      @partial\n      match l with\n      | x :: rest -> if i = 0 do x else go rest (i - 1)\n    in go xs n\n\n  pub let concat a b = List.fold (fn acc x -> x :: acc) b (List.rev a)\n\n  pub let is_empty xs = match xs with\n    | [] -> true\n    | _ -> false\n\n  pub let flatten xss = List.fold (fn acc xs -> List.concat acc xs) [] xss\n\n  pub let map (f: 'a -> 'b) (xs: 'a list) : 'b list =\n    let rec go acc l =\n      match l with\n      | [] -> List.rev acc\n      | x :: rest -> go (f x :: acc) rest\n    in go [] xs\n\n  pub let filter (f: 'a -> bool) (xs: 'a list) : 'a list =\n    let rec go acc l =\n      match l with\n      | [] -> List.rev acc\n      | x :: rest ->\n        if f x do go (x :: acc) rest\n        else go acc rest\n    in go [] xs\n\n  pub let find (f: 'a -> bool) (xs: 'a list) : 'a option =\n    let rec go l =\n      match l with\n      | [] -> None\n      | x :: rest -> if f x do Some x else go rest\n    in go xs\n\n  pub let exists (f: 'a -> bool) (xs: 'a list) : bool =\n    let rec go l =\n      match l with\n      | [] -> false\n      | x :: rest -> if f x do true else go rest\n    in go xs\n\n  pub let forall (f: 'a -> bool) (xs: 'a list) : bool =\n    let rec go l =\n      match l with\n      | [] -> true\n      | x :: rest -> if f x do go rest else false\n    in go xs\n\n  pub let zip (xs: 'a list) (ys: 'b list) : ('a * 'b) list =\n    let rec go acc a b =\n      match a with\n      | [] -> List.rev acc\n      | x :: ra ->\n        @partial\n        match b with\n        | y :: rb -> go ((x, y) :: acc) ra rb\n    in go [] xs ys\n\n  pub let mapi (f: int -> 'a -> 'b) (xs: 'a list) : 'b list =\n    let rec go i acc l =\n      match l with\n      | [] -> List.rev acc\n      | x :: rest -> go (i + 1) (f i x :: acc) rest\n    in go 0 [] xs\n\n  pub let sort (cmp: 'a -> 'a -> int) (xs: 'a list) : 'a list =\n    let rec insert x sorted =\n      match sorted with\n      | [] -> [x]\n      | y :: rest ->\n        if cmp x y < 1 do x :: sorted\n        else y :: insert x rest\n    in\n    List.fold (fn acc x -> insert x acc) [] xs\n\n  pub let fold_right (f: 'a -> 'b -> 'b) (xs: 'a list) (acc: 'b) : 'b =\n    let rec go l =\n      match l with\n      | [] -> acc\n      | x :: rest -> f x (go rest)\n    in go xs\n\n  pub let find_map (f: 'a -> 'b option) (xs: 'a list) : 'b option =\n    let rec go l =\n      match l with\n      | [] -> None\n      | x :: rest ->\n        match f x with\n        | Some _ as result -> result\n        | None -> go rest\n    in go xs\n\n  pub let assoc_opt key xs =\n    let rec go l =\n      match l with\n      | [] -> None\n      | (k, v) :: rest ->\n        if k = key do Some v else go rest\n    in go xs\n\n  pub let init n f =\n    let rec go i acc =\n      if i < 0 do acc\n      else go (i - 1) (f i :: acc)\n    in go (n - 1) []\n\n  pub let concat_map f xs =\n    List.flatten (List.map f xs)\n\n  pub let iter2 f xs ys =\n    let rec go a b =\n      match a with\n      | [] -> ()\n      | x :: ra ->\n        @partial\n        match b with\n        | y :: rb -> f x y; go ra rb\n    in go xs ys\n\n  pub let map2 (f: 'a -> 'b -> 'c) (xs: 'a list) (ys: 'b list) : 'c list =\n    let rec go acc a b =\n      match a with\n      | [] -> List.rev acc\n      | x :: ra ->\n        @partial\n        match b with\n        | y :: rb -> go (f x y :: acc) ra rb\n    in go [] xs ys\n\n  pub let fold2 (f: 'c -> 'a -> 'b -> 'c) (acc: 'c) (xs: 'a list) (ys: 'b list) : 'c =\n    let rec go a l1 l2 =\n      match l1 with\n      | [] -> a\n      | x :: r1 ->\n        @partial\n        match l2 with\n        | y :: r2 -> go (f a x y) r1 r2\n    in go acc xs ys\n\n  pub let forall2 (f: 'a -> 'b -> bool) (xs: 'a list) (ys: 'b list) : bool =\n    let rec go a b =\n      match a with\n      | [] -> true\n      | x :: ra ->\n        @partial\n        match b with\n        | y :: rb -> if f x y do go ra rb else false\n    in go xs ys\n\n  pub let iteri (f: int -> 'a -> unit) (xs: 'a list) : unit =\n    let rec go i l =\n      match l with\n      | [] -> ()\n      | x :: rest -> f i x; go (i + 1) rest\n    in go 0 xs\n\n  pub let mem_assoc key xs =\n    let rec go l =\n      match l with\n      | [] -> false\n      | (k, _) :: rest ->\n        if k = key do true else go rest\n    in go xs\n\n  pub let assoc key xs =\n    match List.assoc_opt key xs with\n    | Some v -> v\n    | None -> failwith \"List.assoc: not found\"\n\n  pub let iter (f: 'a -> unit) (xs: 'a list) : unit =\n    let rec go xs =\n      match xs with\n      | [] -> ()\n      | x :: rest -> f x; go rest\n    in go xs\n\n  pub let mem x xs =\n    let rec go xs =\n      match xs with\n      | [] -> false\n      | y :: rest -> if x = y do true else go rest\n    in go xs\n\n  pub let rev_append xs ys =\n    let rec go xs acc =\n      match xs with\n      | [] -> acc\n      | x :: rest -> go rest (x :: acc)\n    in go xs ys\n\n  pub let nth_opt xs n =\n    let rec go xs i =\n      match xs with\n      | [] -> None\n      | x :: rest -> if i = 0 do Some x else go rest (i - 1)\n    in go xs n\n\n  pub let find_index f xs =\n    let rec go xs i =\n      match xs with\n      | [] -> None\n      | x :: rest -> if f x do Some i else go rest (i + 1)\n    in go xs 0\n\n  pub let filteri f xs =\n    let rec go xs i acc =\n      match xs with\n      | [] -> List.rev acc\n      | x :: rest ->\n        if f i x do go rest (i + 1) (x :: acc)\n        else go rest (i + 1) acc\n    in go xs 0 []\n\n  pub let filter_map (f: 'a -> 'b option) (xs: 'a list) : 'b list =\n    let rec go xs acc =\n      match xs with\n      | [] -> List.rev acc\n      | x :: rest ->\n        match f x with\n        | Some y -> go rest (y :: acc)\n        | None -> go rest acc\n    in go xs []\n\n  pub let sort_uniq cmp xs =\n    let sorted = List.sort cmp xs in\n    let rec dedup xs =\n      match xs with\n      | [] -> []\n      | x :: [] -> x :: []\n      | x :: y :: rest ->\n        if cmp x y = 0 do dedup (y :: rest)\n        else x :: dedup (y :: rest)\n    in dedup sorted\nend\n","stdlib/array_extra.mml":"module Array =\n  pub let init n f =\n    if n <= 0 do #[]\n    else\n      let arr = Array.make n (f 0) in\n      let rec go i =\n        if i >= n do arr\n        else (Array.set arr i (f i); go (i + 1))\n      in go 1\n\n  pub let map f arr =\n    let n = Array.length arr in\n    if n = 0 do #[]\n    else\n      let result = Array.make n (f (Array.get arr 0)) in\n      let rec go i =\n        if i >= n do result\n        else (Array.set result i (f (Array.get arr i)); go (i + 1))\n      in go 1\n\n  pub let iter f arr =\n    let n = Array.length arr in\n    let rec go i =\n      if i >= n do ()\n      else (f (Array.get arr i); go (i + 1))\n    in go 0\n\n  pub let iteri f arr =\n    let n = Array.length arr in\n    let rec go i =\n      if i >= n do ()\n      else (f i (Array.get arr i); go (i + 1))\n    in go 0\n\n  pub let forall f arr =\n    let n = Array.length arr in\n    let rec go i =\n      if i >= n do true\n      else if f (Array.get arr i) do go (i + 1)\n      else false\n    in go 0\n\n  pub let fold f acc arr =\n    let n = Array.length arr in\n    let rec go i a =\n      if i >= n do a\n      else go (i + 1) (f a (Array.get arr i))\n    in go 0 acc\nend\n","stdlib/result.mml":"module Result =\n  pub type ('a, 'b) t = Ok of 'a | Err of 'b\n  pub let map (f: 'a -> 'c) (r: ('a, 'b) t) : ('c, 'b) t =\n    match r with\n    | Ok v -> Ok (f v)\n    | Err e -> Err e\n  pub let bind (f: 'a -> ('c, 'b) t) (r: ('a, 'b) t) : ('c, 'b) t =\n    match r with\n    | Ok v -> f v\n    | Err e -> Err e\n  pub let unwrap (r: ('a, 'b) t) : 'a =\n    @partial\n    match r with\n    | Ok v -> v\nend\n;;\nopen Result\n","stdlib/option.mml":"module Option =\n  pub let map (f: 'a -> 'b) (opt: 'a option) : 'b option =\n    match opt with\n    | Some x -> Some (f x)\n    | None -> None\n  pub let bind (f: 'a -> 'b option) (opt: 'a option) : 'b option =\n    match opt with\n    | Some x -> f x\n    | None -> None\n  pub let unwrap (opt: 'a option) : 'a =\n    @partial\n    match opt with\n    | Some x -> x\n  pub let unwrap_or (default: 'a) (opt: 'a option) : 'a =\n    match opt with\n    | Some x -> x\n    | None -> default\n  pub let is_some (opt: 'a option) : bool =\n    match opt with\n    | Some _ -> true\n    | None -> false\n  pub let is_none (opt: 'a option) : bool =\n    match opt with\n    | Some _ -> false\n    | None -> true\n  pub let to_list (opt: 'a option) : 'a list =\n    match opt with\n    | Some x -> [x]\n    | None -> []\n  pub let iter (f: 'a -> unit) (opt: 'a option) : unit =\n    match opt with\n    | Some x -> f x\n    | None -> ()\n  pub let flat_map (f: 'a -> 'b option) (opt: 'a option) : 'b option =\n    match opt with\n    | Some x -> f x\n    | None -> None\nend\n","stdlib/buffer.mml":"module Buffer =\n  pub type t = { mut data: byte array; mut len: int }\n\n  pub let create (n: int) : t =\n    { data = Array.make (if n < 16 do 16 else n) #00; len = 0 }\n\n  pub let length (buf: t) : int = buf.len\n\n  pub let clear (buf: t) : unit =\n    buf.len := 0\n\n  pub let grow (buf: t) (needed: int) : unit =\n    let cap = Array.length buf.data in\n    if buf.len + needed > cap do\n      let new_cap = Math.max (cap * 2) (buf.len + needed) in\n      let new_data = Array.make new_cap #00 in\n      let rec copy i =\n        if i < buf.len do\n          Array.set new_data i (Array.get buf.data i);\n          copy (i + 1)\n        else ()\n      in\n      copy 0;\n      buf.data := new_data\n    else ()\n\n  pub let add_byte (buf: t) (b: byte) : unit =\n    Buffer.grow buf 1;\n    Array.set buf.data buf.len b;\n    buf.len := buf.len + 1\n\n  pub let add_string (buf: t) (s: string) : unit =\n    let bytes = String.to_byte_array s in\n    let n = Array.length bytes in\n    Buffer.grow buf n;\n    let rec copy i =\n      if i < n do\n        Array.set buf.data (buf.len + i) (Array.get bytes i);\n        copy (i + 1)\n      else ()\n    in\n    copy 0;\n    buf.len := buf.len + n\n\n  pub let sub (buf: t) (pos: int) (len: int) : string =\n    String.of_byte_array (Array.sub buf.data pos len)\n\n  pub let truncate (buf: t) (n: int) : unit =\n    buf.len := n\n\n  pub let contents (buf: t) : string =\n    String.of_byte_array (Array.sub buf.data 0 buf.len)\n\n  pub let add_buffer (dst: t) (src: t) : unit =\n    let n = src.len in\n    Buffer.grow dst n;\n    let rec copy i =\n      if i < n do\n        Array.set dst.data (dst.len + i) (Array.get src.data i);\n        copy (i + 1)\n      else ()\n    in\n    copy 0;\n    dst.len := dst.len + n\nend\n","stdlib/hash.mml":"class Hash 'a =\n  hash : 'a -> int\nend\n\ninstance Hash int =\n  let hash n = n\nend\ninstance Hash string =\n  let hash s =\n    let bytes = String.to_byte_array s in\n    fold (fn h b -> h * 31 + Byte.to_int b) 5381 bytes\nend\ninstance Hash bool =\n  let hash b = if b do 1 else 0\nend\ninstance Hash byte =\n  let hash b = Byte.to_int b\nend\ninstance Hash rune =\n  let hash r = Rune.to_int r\nend\n","stdlib/hashtbl.mml":"module Hashtbl =\n  pub type ('k, 'v) t = { mut buckets: ('k * 'v) list array; mut size: int }\n  pub let create (n: int) =\n    let cap = if n < 16 do 16 else n in\n    { buckets = Array.make cap []; size = 0 }\n\n  pub let clear tbl =\n    let cap = Array.length tbl.buckets in\n    tbl.buckets := Array.make cap [];\n    tbl.size := 0\n\n  pub let length tbl = tbl.size\n\n  pub let bucket_index tbl (key: 'k) where Hash 'k =\n    let h = hash key in\n    let h = if h < 0 do 0 - h else h in\n    h mod (Array.length tbl.buckets)\n\n  pub let to_list tbl =\n    let cap = Array.length tbl.buckets in\n    let rec collect i acc =\n      if i >= cap do acc\n      else\n        let bucket = Array.get tbl.buckets i in\n        collect (i + 1) (List.concat bucket acc)\n    in\n    collect 0 []\n\n  let rehash tbl hash_fn =\n    let entries = Hashtbl.to_list tbl in\n    let new_cap = Array.length tbl.buckets * 2 in\n    tbl.buckets := Array.make new_cap [];\n    tbl.size := 0;\n    List.fold (fn _ (k, v) ->\n      let h = hash_fn k in\n      let h = if h < 0 do 0 - h else h in\n      let idx = h mod new_cap in\n      let bucket = Array.get tbl.buckets idx in\n      Array.set tbl.buckets idx ((k, v) :: bucket);\n      tbl.size := tbl.size + 1\n    ) () entries\n\n  pub let set tbl (key: 'k) value where Hash 'k, Eq 'k =\n    let idx = Hashtbl.bucket_index tbl key in\n    let bucket = Array.get tbl.buckets idx in\n    let rec replace = fn\n      | [] -> [(key, value)]\n      | (k, v) :: rest ->\n        if k = key do (key, value) :: rest\n        else (k, v) :: replace rest\n    in\n    let new_bucket = replace bucket in\n    let grew = List.length new_bucket > List.length bucket in\n    Array.set tbl.buckets idx new_bucket;\n    if grew do do\n      tbl.size := tbl.size + 1;\n      if tbl.size > Array.length tbl.buckets * 2 do\n        Hashtbl.rehash tbl hash\n      else ()\n    end else ()\n\n  pub let get tbl (key: 'k) where Hash 'k, Eq 'k =\n    let idx = Hashtbl.bucket_index tbl key in\n    let bucket = Array.get tbl.buckets idx in\n    let rec find = fn\n      | [] -> None\n      | (k, v) :: rest ->\n        if k = key do Some v\n        else find rest\n    in\n    find bucket\n\n  pub let has tbl (key: 'k) where Hash 'k, Eq 'k =\n    match Hashtbl.get tbl key with\n    | Some _ -> true\n    | None -> false\n\n  pub let remove tbl (key: 'k) where Hash 'k, Eq 'k =\n    let idx = Hashtbl.bucket_index tbl key in\n    let bucket = Array.get tbl.buckets idx in\n    let new_bucket = List.filter (fn (k, _) -> k <> key) bucket in\n    do\n      if List.length new_bucket < List.length bucket do\n        tbl.size := tbl.size - 1\n      else ()\n    end;\n    Array.set tbl.buckets idx new_bucket\n\n  pub let find tbl key =\n    match Hashtbl.get tbl key with\n    | Some v -> v\n    | None -> failwith \"Hashtbl.find: key not found\"\n\n  pub let fold f tbl acc =\n    let entries = Hashtbl.to_list tbl in\n    List.fold (fn a (k, v) -> f k v a) acc entries\n\n  pub let iter f tbl =\n    let entries = Hashtbl.to_list tbl in\n    List.iter (fn (k, v) -> f k v) entries\n\n  pub let keys tbl =\n    List.map (fn (k, _) -> k) (Hashtbl.to_list tbl)\n\n  pub let values tbl =\n    List.map (fn (_, v) -> v) (Hashtbl.to_list tbl)\nend\n","stdlib/ref.mml":"module Ref =\n  pub type 'a t = { mut contents: 'a }\n  pub let create v = { contents = v }\n  pub let get r = r.contents\n  pub let set r v = r.contents := v\nend\n","stdlib/dynarray.mml":"module Dynarray =\n  pub type 'a t = { mut arr: 'a array; mut count: int }\n\n  pub let create n default =\n    { arr = Array.make (if n < 16 do 16 else n) default; count = 0 }\n\n  pub let length d = d.count\n\n  pub let get d i =\n    if i < 0 || i >= d.count do failwith \"Dynarray.get: index out of bounds\"\n    else Array.get d.arr i\n\n  pub let set d i v =\n    if i < 0 || i >= d.count do failwith \"Dynarray.set: index out of bounds\"\n    else Array.set d.arr i v\n\n  pub let grow d needed default =\n    let cap = Array.length d.arr in\n    if d.count + needed > cap do\n      let new_cap = Math.max (cap * 2) (d.count + needed) in\n      let new_arr = Array.make new_cap default in\n      let rec copy i =\n        if i < d.count do\n          Array.set new_arr i (Array.get d.arr i);\n          copy (i + 1)\n        else ()\n      in\n      copy 0;\n      d.arr := new_arr\n    else ()\n\n  pub let empty () =\n    { arr = #[]; count = 0 }\n\n  pub let push d v =\n    Dynarray.grow d 1 v;\n    Array.set d.arr d.count v;\n    d.count := d.count + 1\n\n  pub let pop d =\n    if d.count = 0 do failwith \"Dynarray.pop: empty\"\n    else\n      d.count := d.count - 1;\n      Array.get d.arr d.count\n\n  pub let clear d =\n    d.count := 0\n\n  pub let to_list d =\n    let rec collect i acc =\n      if i < 0 do acc\n      else collect (i - 1) (Dynarray.get d i :: acc)\n    in\n    collect (d.count - 1) []\n\n  pub let to_array d =\n    Array.sub d.arr 0 d.count\nend\n","stdlib/map.mml":"newtype ('k, 'v) map = MMap of ('k * 'v) list\n;;\nmodule Map =\n  pub let empty () : ('k, 'v) map = MMap []\n\n  pub let rec has k (MMap m) = match m with\n    | [] -> false\n    | (k2, _) :: rest -> if k = k2 do true else has k (MMap rest)\n\n  pub let rec get k (MMap m) = match m with\n    | [] -> None\n    | (k2, v) :: rest -> if k = k2 do Some v else get k (MMap rest)\n\n  pub let set k v (MMap m) =\n    let rec go acc lst = match lst with\n      | [] -> MMap (List.rev ((k, v) :: acc))\n      | (k2, _) :: rest when k = k2 -> MMap (List.rev_append ((k, v) :: acc) rest)\n      | entry :: rest -> go (entry :: acc) rest\n    in go [] m\n\n  pub let rec remove k (MMap m) = match m with\n    | [] -> MMap []\n    | (k2, _) :: rest when k = k2 -> MMap rest\n    | entry :: rest -> match remove k (MMap rest) with MMap r -> MMap (entry :: r)\n\n  pub let size (MMap m) = List.length m\n\n  pub let rec keys (MMap m) = match m with\n    | [] -> []\n    | (k, _) :: rest -> k :: keys (MMap rest)\n\n  pub let rec values (MMap m) = match m with\n    | [] -> []\n    | (_, v) :: rest -> v :: values (MMap rest)\n\n  pub let to_list (MMap m) : ('k * 'v) list = m\n\n  pub let of_list (pairs : ('k * 'v) list) : ('k, 'v) map =\n    List.fold (fn acc p -> match p with (k, v) -> set k v acc) (MMap []) pairs\nend\n;;\ninstance Map (('k, 'v) map) 'k 'v =\n  let of_list = Map.of_list\n  let get = Map.get\n  let set = Map.set\n  let has = Map.has\n  let remove = Map.remove\n  let size = Map.size\n  let keys = Map.keys\n  let values = Map.values\n  let to_list = Map.to_list\nend\n;;\ninstance Iter (('k, 'v) map) ('k * 'v) =\n  let fold f acc (MMap m) =\n    let rec go a l = match l with\n      | [] -> a\n      | x :: rest -> go (f a x) rest\n    in go acc m\nend\n;;\ninstance Show (('k, 'v) map) where Show 'k, Show 'v =\n  let show (MMap m) = match m with\n    | [] -> \"#{}\"\n    | _ ->\n      let inner = List.fold (fn acc kv -> match kv with (k, v) ->\n        let entry = show k ^ \": \" ^ show v in\n        if acc = \"\" do entry else acc ^ \"; \" ^ entry\n      ) \"\" m in\n      \"#{\" ^ inner ^ \"}\"\nend\n;;\ninstance Index (('k, 'v) map) 'k 'v =\n  let at k m = match Map.get k m with\n    | Some v -> v\n    | None -> failwith \"key not found in map\"\nend\n","stdlib/set.mml":"newtype 'a set = MSet of ('a, unit) map\n;;\nmodule Set =\n  pub let empty () : 'a set = MSet (Map.empty ())\n\n  pub let singleton (x : 'a) : 'a set = MSet (Map.set x () (Map.empty ()))\n\n  pub let of_list xs : 'a set =\n    MSet (List.fold (fn acc x -> Map.set x () acc) (Map.empty ()) xs)\n\n  pub let add elem (MSet s) : 'a set = MSet (Map.set elem () s)\n\n  pub let remove elem (MSet s) : 'a set = MSet (Map.remove elem s)\n\n  pub let mem elem (MSet s) = Map.has elem s\n\n  pub let size (MSet s) = Map.size s\n\n  pub let to_list (MSet s) = Map.keys s\n\n  pub let union (MSet s1) (MSet s2) : 'a set =\n    MSet (List.fold (fn acc x -> Map.set x () acc) s2 (Map.keys s1))\n\n  pub let inter (MSet s1) (MSet s2) : 'a set =\n    MSet (List.fold (fn acc x ->\n      if Map.has x s2 do Map.set x () acc else acc\n    ) (Map.empty ()) (Map.keys s1))\n\n  pub let diff (MSet s1) (MSet s2) : 'a set =\n    MSet (List.fold (fn acc x ->\n      if not (Map.has x s2) do Map.set x () acc else acc\n    ) (Map.empty ()) (Map.keys s1))\n\n  pub let is_empty (MSet s) = Map.size s = 0\n\n  pub let is_subset (MSet s1) (MSet s2) =\n    List.forall (fn x -> Map.has x s2) (Map.keys s1)\nend\n;;\ninstance Iter ('a set) 'a =\n  let fold f acc (MSet s) =\n    let rec go a l = match l with\n      | [] -> a\n      | x :: rest -> go (f a x) rest\n    in go acc (Map.keys s)\nend\n;;\ninstance Show ('a set) where Show 'a =\n  let show (MSet s) = match Map.keys s with\n    | [] -> \"#{}\"\n    | ks ->\n      let inner = List.fold (fn acc x ->\n        if acc = \"\" do show x else acc ^ \"; \" ^ show x\n      ) \"\" ks in\n      \"#{\" ^ inner ^ \"}\"\nend\n","stdlib/enum.mml":"module Enum =\n  pub let reduce f xs =\n    @partial\n    match xs with\n    | x :: rest -> List.fold f x rest\n\n  pub let sum xs = List.fold (fn a b -> a + b) 0 xs\n\n  pub let count f xs =\n    List.fold (fn acc x -> if f x do acc + 1 else acc) 0 xs\n\n  pub let take n xs =\n    let rec go i acc l =\n      if i >= n do List.rev acc\n      else match l with\n        | [] -> List.rev acc\n        | x :: rest -> go (i + 1) (x :: acc) rest\n    in go 0 [] xs\n\n  pub let drop n xs =\n    let rec go i l =\n      if i >= n do l\n      else match l with\n        | [] -> []\n        | _ :: rest -> go (i + 1) rest\n    in go 0 xs\n\n  pub let take_while f xs =\n    let rec go acc l =\n      match l with\n      | [] -> List.rev acc\n      | x :: rest ->\n        if f x do go (x :: acc) rest\n        else List.rev acc\n    in go [] xs\n\n  pub let drop_while f xs =\n    let rec go l =\n      match l with\n      | [] -> []\n      | x :: rest ->\n        if f x do go rest\n        else l\n    in go xs\n\n  pub let flat_map f xs = List.flatten (List.map f xs)\n\n  pub let each f xs = List.fold (fn _ x -> f x) () xs\n\n  pub let reject f xs = List.filter (fn x -> not (f x)) xs\n\n  pub let enumerate xs = List.mapi (fn i x -> (i, x)) xs\n\n  pub let join sep xs =\n    match xs with\n    | [] -> \"\"\n    | first :: rest ->\n      List.fold (fn acc x -> acc ^ sep ^ x) first rest\n\n  pub let chunk n xs =\n    let rec go acc l =\n      match l with\n      | [] -> List.rev acc\n      | _ -> go (Enum.take n l :: acc) (Enum.drop n l)\n    in go [] xs\n\n  pub let dedup xs =\n    let rec go prev acc l =\n      match l with\n      | [] -> List.rev acc\n      | x :: rest ->\n        if x = prev do go prev acc rest\n        else go x (x :: acc) rest\n    in match xs with\n      | [] -> []\n      | x :: rest -> go x [x] rest\n\n  pub let uniq xs =\n    List.rev (List.fold (fn acc x ->\n      if List.exists (fn y -> y = x) acc do acc\n      else x :: acc\n    ) [] xs)\n\n  pub let scan f init xs =\n    List.rev (List.fold (fn acc x ->\n      match acc with\n      | [] -> [f init x]\n      | prev :: _ -> f prev x :: acc\n    ) [init] xs)\n\n  pub let intersperse sep xs =\n    match xs with\n    | [] -> []\n    | first :: rest ->\n      List.fold (fn acc x -> List.concat acc [sep; x]) [first] rest\n\n  pub let zip_with f xs ys =\n    List.map (fn p -> match p with (a, b) -> f a b) (List.zip xs ys)\n\n  pub let min_by f xs =\n    @partial\n    match xs with\n    | x :: rest ->\n      List.fold (fn best y -> if f y < f best do y else best) x rest\n\n  pub let max_by f xs =\n    @partial\n    match xs with\n    | x :: rest ->\n      List.fold (fn best y -> if f y > f best do y else best) x rest\n\n  pub let group_by f xs =\n    List.fold (fn m x ->\n      let k = f x in\n      match get k m with\n      | None -> set k [x] m\n      | Some vs -> set k (List.concat vs [x]) m\n    ) #{} xs\nend\n","stdlib/seq.mml":"type 'a seq = ('a -> unit) -> unit\n;;\neffect SeqStop =\n  __seq_stop : unit -> unit\nend\nmodule Seq =\n  pub let range start stop : int seq = fn yield ->\n    let rec go i =\n      if i >= stop do ()\n      else (yield i; go (i + 1))\n    in go start\n\n  pub let of_list xs : 'a seq = fn yield ->\n    let rec go l =\n      match l with\n      | [] -> ()\n      | x :: rest -> yield x; go rest\n    in go xs\n\n  pub let repeat x : 'a seq = fn yield ->\n    let rec go u = yield x; go u\n    in go 0\n\n  pub let iterate seed step : 'a seq = fn yield ->\n    let rec go x = yield x; go (step x)\n    in go seed\n\n  pub let map f s : 'a seq = fn yield ->\n    s (fn x -> yield (f x))\n\n  pub let filter f s : 'a seq = fn yield ->\n    s (fn x -> if f x do yield x else ())\n\n  pub let take n (s : 'a seq) : 'a seq = fn yield ->\n    let mut i = 0 in\n    try\n      s (fn x ->\n        if i >= n do perform __seq_stop ()\n        else (yield x; i := i + 1))\n    with\n    | __seq_stop () -> ()\n\n  pub let take_while f (s : 'a seq) : 'a seq = fn yield ->\n    try\n      s (fn x ->\n        if f x do yield x\n        else perform __seq_stop ())\n    with\n    | __seq_stop () -> ()\n\n  pub let drop n (s : 'a seq) : 'a seq = fn yield ->\n    let mut i = 0 in\n    s (fn x ->\n      if i >= n do yield x\n      else i := i + 1)\n\n  pub let drop_while f (s : 'a seq) : 'a seq = fn yield ->\n    let mut dropping = true in\n    s (fn x ->\n      if dropping do\n        (if f x do () else (dropping := false; yield x))\n      else yield x)\n\n  pub let flat_map (f : 'a -> 'b seq) (s : 'a seq) : 'b seq = fn yield ->\n    s (fn x -> (f x) yield)\n\n  pub let enumerate (s : 'a seq) : 'b seq = fn yield ->\n    let mut i = 0 in\n    s (fn x ->\n      yield (i, x);\n      i := i + 1)\n\n  pub let chunk n (s : 'a seq) : 'b seq = fn yield ->\n    let mut buf = [] in\n    let mut count = 0 in\n    s (fn x ->\n      buf := List.concat buf [x];\n      count := count + 1;\n      if count >= n do\n        (yield buf; buf := []; count := 0)\n      else ());\n    if count > 0 do yield buf else ()\n\n  pub let to_list (s : 'a seq) =\n    let mut acc = [] in\n    s (fn x -> acc := x :: acc);\n    List.rev acc\n\n  pub let fold f init (s : 'a seq) =\n    let mut acc = init in\n    s (fn x -> acc := f acc x);\n    acc\n\n  pub let each (f : 'a -> unit) (s : 'a seq) = s f\n\n  pub let count (s : 'a seq) =\n    let mut n = 0 in\n    s (fn _ -> n := n + 1);\n    n\n\n  pub let sum (s : int seq) =\n    let mut total = 0 in\n    s (fn x -> total := total + x);\n    total\n\n  pub let find f (s : 'a seq) =\n    let mut result = None in\n    let _ = try\n      s (fn x ->\n        if f x do (result := Some x; perform __seq_stop ())\n        else ())\n    with\n    | __seq_stop () -> ()\n    in result\n\n  pub let any f (s : 'a seq) =\n    let mut result = false in\n    let _ = try\n      s (fn x ->\n        if f x do (result := true; perform __seq_stop ())\n        else ())\n    with\n    | __seq_stop () -> ()\n    in result\n\n  pub let all f (s : 'a seq) =\n    let mut result = true in\n    let _ = try\n      s (fn x ->\n        if f x do ()\n        else (result := false; perform __seq_stop ()))\n    with\n    | __seq_stop () -> ()\n    in result\nend\n","stdlib/fmt.mml":"module Fmt =\n  pub let pad_left (n: int) (c: string) (s: string) : string =\n    let len = String.length s in\n    if len >= n do s\n    else\n      let rec pad acc remaining =\n        if remaining <= 0 do acc ^ s\n        else pad (acc ^ c) (remaining - 1)\n      in\n      pad \"\" (n - len)\n\n  pub let pad_right (n: int) (c: string) (s: string) : string =\n    let len = String.length s in\n    if len >= n do s\n    else\n      let rec pad acc remaining =\n        if remaining <= 0 do s ^ acc\n        else pad (acc ^ c) (remaining - 1)\n      in\n      pad \"\" (n - len)\n\n  pub let int_to_hex (n: int) : string =\n    let digits = \"0123456789abcdef\" in\n    if n = 0 do \"0\"\n    else\n      let rec go num acc =\n        if num = 0 do acc\n        else\n          let d = num mod 16 in\n          let d = if d < 0 do d + 16 else d in\n          let ch = String.sub digits d 1 in\n          go (num / 16) (ch ^ acc)\n      in\n      let abs_n = if n < 0 do 0 - n else n in\n      let hex = go abs_n \"\" in\n      if n < 0 do \"-\" ^ hex else hex\n\n  pub let int_to_bin (n: int) : string =\n    if n = 0 do \"0\"\n    else\n      let rec go num acc =\n        if num = 0 do acc\n        else\n          let bit = if num mod 2 = 0 do \"0\" else \"1\" in\n          go (num / 2) (bit ^ acc)\n      in\n      let abs_n = if n < 0 do 0 - n else n in\n      let bin = go abs_n \"\" in\n      if n < 0 do \"-\" ^ bin else bin\n\n  pub let int_to_oct (n: int) : string =\n    if n = 0 do \"0\"\n    else\n      let rec go num acc =\n        if num = 0 do acc\n        else\n          let d = num mod 8 in\n          let d = if d < 0 do d + 8 else d in\n          go (num / 8) (show d ^ acc)\n      in\n      let abs_n = if n < 0 do 0 - n else n in\n      let oct = go abs_n \"\" in\n      if n < 0 do \"-\" ^ oct else oct\n\n  pub let zero_pad (width: int) (s: string) : string =\n    Fmt.pad_left width \"0\" s\nend\n","stdlib/compat.mml":"let compare a b =\n  if a < b do -1\n  else if a > b do 1\n  else 0\n\nlet int_of_string s =\n  match String.to_int s with\n  | Some n -> n\n  | None -> failwith $\"int_of_string: invalid argument \\\"{s}\\\"\"\n\nlet float_of_string s =\n  match String.to_float s with\n  | Some f -> f\n  | None -> failwith $\"float_of_string: invalid argument \\\"{s}\\\"\"\n\nlet max (a : int) (b : int) : int = if a > b do a else b\n\nlet min (a : int) (b : int) : int = if a < b do a else b\n\nlet fst (a, _) = a\n\nlet snd (_, b) = b\n\nlet list_find f xs =\n  match List.find f xs with\n  | Some x -> x\n  | None -> failwith \"list_find: not found\"\n"};

// ---- Public API ----
global.MiniML = {
  loadBundle: loadBundle,
  loadBundleBinary: loadBundleBinary,
  callClosure: callClosure,
  ppValue: ppValue,
  RuntimeError: RuntimeError,
  VUNIT: VUNIT,
  STDLIB_SOURCES: STDLIB_SOURCES,
  resetProfile: resetProfile,
  dumpProfile: function() { dumpProfile(OPCODE_NAMES); },
};

})(typeof window !== "undefined" ? window : globalThis);
